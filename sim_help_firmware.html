<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <title></title>
    <style type="text/css">
/*<![CDATA[*/
    :link { color: #0563C1 }
    :visited { color: #954F72 }
    b.cleanuphtml-4 {font-style: italic}
    p.cleanuphtml-3 {font-weight: bold}
    p.cleanuphtml-2 {text-align: center}
    a.cleanuphtml-1 {font-weight: bold}
    /*]]>*/
    </style>
  <!-- Clean HTML generated by http://www.cleanuphtml.com/ -->
	<meta name="Generator" content="Cleanup HTML"></head>
  <body>
    <div class="WordSection1">
      <h1>
        <a name="_Toc438322850">Microcódigo en WepSIM</a>
      </h1>
      <p>
         
      </p>
      <p>
        El microcódigo se carga a través de un fichero de texto que tiene tres secciones:
      </p>
      <p>
        1.    Lista de microprogramas
      </p>
      <p>
        2.    Nombrado de registros
      </p>
      <p>
        3.    Pseudo-instrucciones
      </p>
      <p>
        La lista de microprogramas comienza con el código del <i>fetch</i>.<br />
        Un ejemplo de microprograma de <b>fetch</b> básico sería:
      </p>
      <p>
        fetch
      </p>
      <p>
        {
      </p>
      <p>
                fetch:    (T2, C0=1),
      </p>
      <p>
                             (Ta, Td, R, BW=11, C1),
      </p>
      <p>
                             (M2, C2, T1, C3),
      </p>
      <p>
                              (A0, B=0, C=0000)
      </p>
      <p>
        }
      </p>
      <p class="cleanuphtml-2">
        <a class="cleanuphtml-1" name="_Toc438322900">Figura</a> <b>11</b> <b>Ejemplo de descripción para</b> <b>fetch</b>
      </p>
      <p>
        Las señales de control situadas entre  ( y ) se corresponden con las señales a activar en un ciclo de reloj. Así el fetch necesita cuatro, el último se corresponde con la decodificación
        (incluida en dentro del fetch).
      </p>
      <p>
        A continuación se encuentran el resto de microprogramas asociados a cada instrucción. Cada microprograma sigue el siguiente formato:
      </p>
      <p>
        inst1 Parámetro1 Parámetro2 …
      </p>
      <p>
        {
      </p>
      <p>
                    co=000000,
      </p>
      <p>
                    nwords=1,
      </p>
      <p>
                    R1=reg(25,21),
      </p>
      <p>
                    R2=reg(20,16),
      </p>
      <p>
                   R3=reg(15,11),
      </p>
      <p>
                    {
      </p>
      <p>
                           (Cop=1001, SelP=11, C7, T6, LE,
      </p>
      <p>
                             SelA=10100, SelB=01111, SelE=10111,
      </p>
      <p>
                             A0=1, B=1, C=0)
      </p>
      <p>
                    }
      </p>
      <p>
        }
      </p>
      <p class="cleanuphtml-2">
        <a class="cleanuphtml-1" name="_Toc438322901">Figura</a> <b>12</b> <b>Ejemplo de formato de descripción de una instrucción</b>
      </p>
      <p>
         
      </p>
      <p>
        Donde la primera línea describe el nombre de la instrucción (inst1) y los parámetros que tiene (registros, valores inmediatos, etc.). A continuación se abre un bloque con llaves para
        describir dicha instrucción.
      </p>
      <p>
        El primer campo del ejemplo (co) que indica los 6 bits que identifica unívocamente la instrucción. Esto no es cierto para las instrucciones aritmético-lógicas que comparten el mismo código de
        operación y según el valor del campo cop se diferencian. Un ejemplo de este caso sería:
      </p>
      <p>
         
      </p>
      <p>
        inst1 Parámetro1 Parámetro2 …
      </p>
      <p>
        {
      </p>
      <p>
                    co=000000,
      </p>
      <p class="cleanuphtml-3">
                    cop=0000,
      </p>
      <p>
                    nwords=1,
      </p>
      <p>
                    R1=reg(25,21),
      </p>
      <p>
                    R2=reg(20,16),
      </p>
      <p>
                   R3=reg(15,11),
      </p>
      <p>
                    {
      </p>
      <p>
                           (Cop=1001, SelP=11, C7, T6, LE,
      </p>
      <p>
                             SelA=10100, SelB=01111, SelE=10111,
      </p>
      <p>
                             A0=1, B=1, C=0)
      </p>
      <p>
                    }
      </p>
      <p>
        }
      </p>
      <p class="cleanuphtml-2">
        <a class="cleanuphtml-1" name="_Toc438322902">Figura</a> <b>13</b> <b>Detalle en la descripción de una instrucción: campo cop</b>
      </p>
      <p>
        <br />
        Los siguientes campos indican para cada uno de los parámetros qué tipo es (registro, inmediato o dirección) así como el bit de inicio y final entre los cuales está el valor de dicho
        parámetro.
      </p>
      <p>
        El tipo de parámetro se indica con:
      </p>
      <p>
        ·       parametro1 = reg(bit-inicio, bit-final): para un registro.
      </p>
      <p>
        ·       parametro1 = inm(bit-inicio, bit-final): para un valor inmediato.
      </p>
      <p>
        ·       parametro1 = addr(bit-inicio, bit-final)rel: para una dirección relativa.
      </p>
      <p>
        ·       parametro1 = addr(bit-inicio, bit-final)abs: para una dirección absoluta.
      </p>
      <p>
        A continuación se abre un bloque donde se indicará el microprograma correspondiente a la instrucción. Las señales de cada ciclo están entre paréntesis y se separan dichos ciclos por coma. Si
        solo hay un ciclo no es necesario la coma. Dentro de los paréntesis se indicarán las señales y el valor correspondiente. Si es una señal de un bit, con solo poner el nombre de la señal se
        entenderá que su valor es uno. El valor de la señal se ha de indicar en binario, usando tantos bits como tenga asociado la señal. Las señales y su valor correspondientes se separan usando una
        coma.
      </p>
      <p>
        Para el nombrado de registros se precisa indicar la etiqueta que se usará para cada uno de los 32 registros del banco de registros. Un ejemplo de esta sección es:<br />
        <br />
      </p>
      <p>
        registers
      </p>
      <p>
        {
      </p>
      <p>
                  0=$zero,
      </p>
      <p>
                  1=$at,
      </p>
      <p>
                  2=$v0,
      </p>
      <p>
                  3=$v1,
      </p>
      <p>
                  4=$a0,
      </p>
      <p>
                  5=$a1,
      </p>
      <p>
                   6=$a2,
      </p>
      <p>
                   7=$a3,
      </p>
      <p>
                  .
      </p>
      <p>
                  .
      </p>
      <p>
                  .
      </p>
      <p>
                  24=$t8,        
      </p>
      <p>
                  25=$t9,
      </p>
      <p>
                  26=$k0,
      </p>
      <p>
                  27=$k1,
      </p>
      <p>
                  28=$gp,
      </p>
      <p>
                  29=$sp (stack_pointer),
      </p>
      <p>
                  30=$fp,
      </p>
      <p>
                  31=$ra
      </p>
      <p>
        }
      </p>
      <p class="cleanuphtml-2">
        <a class="cleanuphtml-1" name="_Toc438322903">Figura</a> <b>14</b> <b>Ejemplo de nombrado de registros</b>
      </p>
      <p>
        <br />
        En la que se indican los nombres usados en la arquitectura MIPS32. En este ejemplo el registro 29 etiquetado con $sp tiene el atributo "(stack_pointer)" para indicar que será usado como
        puntero de pila.
      </p>
      <p>
        Por último es posible definir pseudo-instrucciones.<br />
        <br />
      </p><br clear="all" />
      <p>
         
      </p>
      <p>
        Un ejemplo de pseudoinstrucción sería:
      </p>
      <p>
        Pseudoinstructions<br />
        {<br />
                li reg num<br />
                {<br />
                       lui reg sel(31,16,num) ;<br />
                       ori reg reg sel(15,0,num)<br />
                 }<br />
        }
      </p>
      <p>
         
      </p>
      <p class="cleanuphtml-2">
        <a class="cleanuphtml-1" name="_Toc438322904">Figura</a> <b>15</b> <b>Ejemplo de pseudo-instrucción (sección opcional)</b>
      </p>
      <p>
        <br />
        Donde el operador "sel(bit-inicio, bit-final, campo)" permite seleccionar una serie de bits de uno de los campos de la pseudo-instrucción.
      </p>
      <p>
         
      </p>
      <p>
        Un fichero de texto con las tres secciones antes comentadas (microcódigo, nombrado de registro y definición de pseudo-instrucciones) se carga en la pantalla de Firmware. Para acceder a dicha
        pantalla se ha de ir al menú (parte superior derecha) e indicar la opción <i>Firmware</i> (véase la <b class="cleanuphtml-4">Figura 16</b>)
      </p>
      <p>
        <img width="92" height="50" src="sim_help_firmware_archivos/image001.png" alt="" /><img width="893" height="467" id="Imagen 6" src="sim_help_firmware_archivos/image002.jpg" alt="" name=
        "Imagen 6" />
      </p>
      <p class="cleanuphtml-2">
        <a name="_Ref434190846"></a><a name="_Toc438322905"></a><a class="cleanuphtml-1" name="_Ref434190877">Figura</a> <b>16</b> <b>Pantalla principal: opción de carga de firmware</b>
      </p>
      <p>
        <br />
        A continuación aparecerá una pantalla con un cuadro de texto que permite indicar el <i>firmware</i> (las tres secciones antes comentadas). Es posible cargar un <i>firmware</i> existente
        usando el botón "Load" de la barra inferior, modificar un <i>firmware</i> anteriormente cargado o salvar el firmware en curso con el botón "Save" de la barra inferior. Una vez se indique el
        firmware es preciso hacer clic en el botón "µcompile" para pasar a binario y cargar en la memoria de control dicho firmware, como se muestra en la <b class="cleanuphtml-4">Figura 17</b>.
      </p>
      <p>
         
      </p>
      <p>
        <img width="92" height="50" src="sim_help_firmware_archivos/image001.png" alt="" /><img width="893" height="466" id="Imagen 13" src="sim_help_firmware_archivos/image003.jpg" alt="" name=
        "Imagen 13" />
      </p>
      <p class="cleanuphtml-2">
        <a name="_Toc438322906"></a><a class="cleanuphtml-1" name="_Ref434191423">Figura</a> <b>17</b> <b>Pantalla firmware: cuadro de texto con firmware a cargar</b>
      </p>
      <p>
        <br />
        Una vez cargado el nuevo <i>firmware</i> correctamente aparecerá la pantalla mostrada en la <b class="cleanuphtml-4">Figura 18</b> en la que se muestra la memoria de control con los valores
        que almacena.
      </p>
      <p>
         
      </p>
      <p>
        <img width="893" height="466" id="Imagen 21" src="sim_help_firmware_archivos/image004.jpg" alt="" name="Imagen 21" />
      </p>
      <p class="cleanuphtml-2">
        <a name="_Toc438322907"></a><a class="cleanuphtml-1" name="_Ref434191551">Figura</a> <b>18</b> <b>Pantalla firmware: firmware finalmente compilado</b>
      </p>
      <p>
        <br />
        El siguiente paso es la carga del programa ensamblador que permita probar este <i>firmware</i>, para ello podemos pulsar el botón "Assembly" de la barra inferior.
      </p>
      <p>
         
      </p>
    </div>
  </body>
</html>
