<! DOCTYPE html PUBLIC "- // W3C // DTD XHTML 1.0 Transitional // EN"
    "Http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
  <Голова>
    <Название> </название>
<meta charset="UTF-8">
<meta http-equ="Content-type" content="text/html; charset = UTF-8">
    <style type="text/css">
/ * <! [CDATA [* /
    : ссылка {цвет: # 0563C1}
    : посетил {цвет: # 954F72}
    p.cleanuphtml-5 {margin-bottom: 8.0pt; line-height: 80%}
    b.cleanuphtml-4 {font-style: italic}
    p.cleanuphtml-3 {font-weight: bold}
    p.cleanuphtml-2 {text-align: center}
    a.cleanuphtml-1 {font-weight: bold}
    / *]]> * /
    </Стиль>

  <! - Очистить HTML, сгенерированный http://www.cleanuphtml.com/ ->
<meta name="Generator" content="Очистить HTML"> </head>
  <Тело>

      <div id="help_firmware_format">
      <h1> Микрокод в WepSIM </h1>

<Р>
</Р>
<Р>
                Микрокод загружается через текстовый файл, у вас есть три раздела:
</Р>
<Р>
1. Список микропрограмм
</Р>
<Р>
2. Регистрация имен
</Р>
<Р>
3. Псевдоинструкции
</Р>
<Р>
                Список микропрограмм начинается с кода <b> fetch </b>.
                Примером микропрограммы базовой выборки может быть:
</Р>
<UL>
<Р>
начать <br>
{<br>
получить: (T2, C0 = 1), <br>
(Ta, Td, R, BW = 11, C1), <br>
(M2, C2, T1, C3), <br>
(A0, B = 0, C = 0000) <br>
}
</Р>
</UL>
<p class="cleanuphtml-2">
<a class="cleanuphtml-1" name="_Toc438322900"> Рисунок </a> <b> 11 </b> <b> Пример описания для </b> <b> извлечения </b>
</Р>
<Р>
Управляющие сигналы, расположенные между скобками (и), соответствуют сигналам, активируемым за один такт. Таким образом, выборка требует четырех тактов, последний соответствует декодированию (включено в выборку).
</Р>
<Р>
Затем следуют остальные микропрограммы, связанные с каждой инструкцией. Каждая микропрограмма имеет этот формат:
</Р>
<UL>
<Р>
inst1 field1 field2 field3 <br>
{<br>
ш = 000000, <br>
nwords = 1, <br>
field1 = р (25,21), <br>
field2 = р (20,16), <br>
field3 = р (15,11), <br>
{<br>
(Cop = 1001, SelP = 11, C7, T6, LC, SelA = 10100, SelB = 01111, SelC = 10111, <br>
A0 = 1, B = 1, C = 0) <br>
} <br>
} <br>
</Р>
</UL>
<p class="cleanuphtml-2">
<a class="cleanuphtml-1" name="_Toc438322901"> Рисунок </a> <b> 12 </b> <b> Пример формата описания для инструкции </b>
</Р>
<Р>

</Р>
<Р>
Где первая строка описывает имя команды (inst1) и параметры, которые имеют (регистры, непосредственные значения и т. Д.). Затем открывается блок с ключами для описания инструкции.
</Р>
<Р>
Первое поле в показанном примере (со) указывает 6 битов, которые однозначно идентифицируют инструкцию. Это не совсем верно для арифметических и логических инструкций, так как возможно использовать один и тот же код операции и дифференцировать значение поля. Примером этого случая будет:
</Р>
<UL>
<Р>

</Р>
<Р>
inst1 field1 field2 field3 <br>
{<br>
ш = 000000, <br>
<Б> Коп = 0000 </b> <br>
nwords = 1, <br>
field1 = р (25,21), <br>
field2 = р (20,16), <br>
field3 = р (15,11), <br>
{<br>
(Cop = 1001, SelP = 11, C7, T6, LC, SelA = 10100, SelB = 01111, SelC = 10111, <br>
A0 = 1, B = 1, C = 0)
} <br>
} <br>
</Р>
</UL>
<p class="cleanuphtml-2">
<a class="cleanuphtml-1" name="_Toc438322902"> Рисунок </a> <b> 13 </b> <b> Подробно в описании инструкции: полевой коп </b>
</Р>
<Р>
<br />
Следующие поля указывают для каждого из параметров, какой тип (регистрация, немедленно или адрес), а также начальный и конечный биты (от 0 до 31), где значение этого параметра.
</Р>
<Р>
Тип параметра обозначается:
</Р>
<UL>
<Li>
параметр1 = рег (последний бит, первый бит), <br> для регистра.
</Li>
<Li>
параметр1 = inm (последний бит, первый бит), <br> для немедленного значения.
</Li>
<Li>
Параметр1 = address (последний бит, первый бит) rel, <br> для относительного (для регистра ПК) адреса.
</Li>
<Li>
Параметр1 = address (последний бит, первый бит) abs, <br> для абсолютного адреса.
</Li>
</UL>
<Р>
Затем открывается новый блок, где микропрограмма дляинструкция описана. Сигналы каждого цикла указаны в скобках, и такие циклы разделены запятыми. Если есть только один цикл, то запятая не нужна. В скобках указываются знаки и соответствующее значение. Единственный битовый сигнал может быть выражен только именем сигнала (это означает, что его значение равно единице). Значение сигнала должно указываться в двоичном формате, используя столько битов, сколько имеет сигнал. Сигналы и их соответствующие значения разделяются запятой.
</Р>
<Р>
Для именования регистров требуется, чтобы метка использовалась для каждого из 32 регистров файла регистров. Пример этого раздела: <br />
<br />
</Р>
<UL>
<Р>
регистры
</Р>
<Р>
	        { <br>
	                  0=($zero, $0), <br>
	                  1=($at, $1), <br>
	                  2=($v0, $2), <br>
	                  3=($v1, $3), <br>
	                  4=($a0, $4), <br>
	                  5=($a1, $5), <br>
	                  6=($a2, $6), <br>
	                  7=($a3, $7), <br>
	                  .  <br>
	                  .  <br>
	                  .  <br>
	                  24=($t8, $24), <br>
	                  25=($t9, $25), <br>
	                  26=($k0, $26), <br>
	                  27=($k1, $27), <br>
	                  28=($gp, $28), <br>
	                  29=($sp, $29) (stack_pointer), <br>
	                  30=($fp, $30), <br>
	                  31=($ra, $31)  <br>
	        }
</Р>
</UL>
<p class="cleanuphtml-2">
<a class="cleanuphtml-1" name="_Toc438322903"> Рисунок </a> <b> 14 </b> <b> Пример именования регистров </b>
</Р>
<Р>
<br />
В последнем примере имена используются там, где имена архитектуры MIPS32. В этом примере регистр 29, помеченный $ sp, имеет атрибут «(stack_pointer)», чтобы указать, что он будет использоваться в качестве указателя стека.
</Р>
<Р>

</Р>
<Р>
Наконец, вы можете определить псевдоинструкции.
Примером будет псевдоинструкция:
</Р>
<UL>
<Р>
Псевдоинструкции <br />
{<br />
li reg1=reg num=inm <br />
{<br />
lui reg1 sel(31,16, num); <br />
ori reg1 reg1 sel(15.0, num) <br />
} <br />
}
</Р>
<Р>

</Р>
</UL>
<p class="cleanuphtml-2">
<a class="cleanuphtml-1" name="_Toc438322904"> Рисунок </a> <b> 15 </b> <b> Пример псевдоинструкции (необязательный раздел) </b>
</Р>
<Р>
<br />
Где оператор «sel (bit-start, bit-end field))» позволяет нам выбрать количество бит одного из полей из псевдоинструкции.
</Р>


<br />
<h3>Резюме с примером</h3>
<center>
<table class="table table-hover table-bordered table-sm"
       cellpadding="2" cellspacing="2" border="1">
<thead>
  <tr>
    <th>Section</th>
    <th>Firmware version 1</th>
    <th>Firmware version 2</th>
  </tr>
</thead>

<tbody>
<tr>
<td rowspan="2">1. List of microprograms</td>
<td>
<pre>


 begin
 {
   fetch: (T2, C0=1),
          (Ta, Td, R, BW=11, C1),
          (M2, C2, T1, C3),
          (A0, B=0, C=0000)
 }
</pre>
</td>
<td>
<pre>
 <b>firmware {
      version  = 2,
      rel_mult = 2,
      endian   = little
 }</b>

 begin
 {
   fetch: (T2, C0=1),
          (Ta, Td, R, BW=11, C1),
          (M2, C2, T1, C3),
          (A0, B=0, C=0000)
 }
</pre>
</td>
</tr>
<tr>
<td>
<pre>
inst1 field1 field2 field3
{
     co=000000,
     cop=00000,
     nwords=1,
     field1=reg(25,21),
     field2=inm(20,16),
     field3=address(15,11)rel,
     {
        (Cop=1001, SelP=11, C7),
        (A0=1, B=1, C=0)
     }
}
</pre>
</td>
<td>
<pre>
inst1 field1 field2 field3
{
   <b>nwords=1,
   oc(31:27)=000000,
   eoc(10:8)=000,
   reg(25:21)=field1,
   inm(20:16)=field2,
   address-rel(15:11)=field3,</b>
   {
      (Cop=1001, SelP=11, C7),
      (A0=1, B=1, C=0)
   }
}
</pre>
</td>
</tr>

<tr>
<td>2. Register naming</td>
<td>
<pre>
registers
{
  0=($zero, $0),
  1=($at, $1),
  .
  .
  28=($gp, $28),
  29=($sp, $29) (stack_pointer),
  30=($fp, $30),
  31=($ra, $31)
}
</pre>
</td>
<td>
<pre>
registers
{
  0=($zero, $0),
  1=($at, $1),
  .
  .
  28=($gp, $28),
  29=($sp, $29) (stack_pointer),
  30=($fp, $30),
  31=($ra, $31)
}
</pre>
</td>
</tr>

<tr>
<td>3. Pseudo-instructions</td>
<td>
<pre>
pseudoinstructions
{
  li reg1=reg num=inm
  {
     lui reg1 sel(31,16,num) ;
     ori reg1 reg1 sel(15,0,num)
  }
}
</pre>
</td>
<td>
<pre>
pseudoinstructions
{
  li reg1=reg num=inm
  {
     lui reg1 sel(31,16,num) ;
     ori reg1 reg1 sel(15,0,num)
  }
}
</pre>
</td>
</tr>
</tbody>
</table>
</center>


      </DIV>


      <div id="help_assembly_format">
      <h1> Ассемблер в WepSIM </h1>

<Р>
</Р>
<Р>
                Код сборки описан в текстовом файле с первым разделом данных (.data) и вторым разделом с кодом (.text) <br />
<br />
В разделе данных можно определить переменные и константы, которые будут оставаться в сегменте данных основной памяти. Раздел начинается с директивы <i> .data </i>. Директивы, которые определяют типы данных, которые могут быть определены:
</Р>
<Р>
& Мидот; <b> .ascii: </b> сопровождается строкой, указывающей ассемблеру создать область памяти с данными и сохранить в ней указанную строку.
</Р>
<Р>
& Мидот; <b> .asciiz: </b> сопровождается строкой, инструктирующей ассемблеру создать область памяти с данными и сохранить связанную строку в виде строки с нулевым символом в конце.
</Р>
<Р>
& Мидот; <b> .byte: </b> сопровождается одним или несколькими значениями, которые составляют часть значения переменной. Если несколько значений, эти значения разделяются запятой. Можно использовать следующие значения: <b> символьные, восьмеричные, шестнадцатеричные и десятичные </b>.
</Р>
<Р>
& Мидот; За <b> .half: </b> следует одно или несколько значений, которые составляют часть значения переменной. Если несколько значений, эти значения разделяются запятой. Можно использовать следующие значения: <b> восьмеричное, шестнадцатеричное и десятичное </b>.
</Р>
<Р>
& Мидот; <b> .word: </b> сопровождается одним или несколькими значениями, которые составляют часть значения переменной. Если несколько значений, эти значения разделяются запятой. Можно использовать следующие значения: <b> восьмеричное, шестнадцатеричное и десятичное </b>.
</Р>
<Р>
& Мидот; <b> .space: </b> За ним следует количество байтов в десятичном формате, которое пользователь хочет выделить.
</Р>
<Р>
                Формат значения предыдущих типов данных:
</Р>
<Р>
& Мидот; <b> Строка: </b> последовательность символов в двойных кавычках. <br />
Например: "Hola 123 \ n"
</Р>
<Р>
& Мидот; <b> Символ: </b> символ, заключенный в простые кавычки. <br />
Например: «с».</Р>
<Р>
& Мидот; <b> Octal: </b> число, начинающееся с нуля, и его цифры меньше восьми.
               Например: 012.
</Р>
<Р>
& Мидот; <b> Шестнадцатеричный: </b> число, которое начинается с префикса 0x, а его цифры от нуля до девяти и буквы a, b, c, d, e и f. <br />
Например: 0x12.
</Р>
<Р>
& Мидот; <b> Десятичное число: </b> число, которое не является восьмеричным или шестнадцатеричным, и его цифры находятся в диапазоне от нуля до девяти (включительно). <br />
Например: 12.
</Р>
<Р>
В разделе кода вы можете определить подпрограммы, находящиеся в сегменте кода основной памяти. Раздел начинается с директивы <i> .text </i>.
</Р>
<Р>

</Р>
<Р>
Пример программы будет:
</Р>
<UL>

<pre class="font-monospace">
.data
  age1:      .word 0x12345678, 20 
  alter2:    .word 20, 10 
  resultado: .word 0 
  # 32-битное слово, инициализированное десятичным
  texto:     .ascii  "Hola \t" 
  texto2:    .asciiz "Hola \t" 
  hueco:     .space 16 

.text 
.globl main 
 main: li $3 2 
       li $4 1 
       li $5 0 
</pre>

</UL>
<p class="cleanuphtml-2">
<a class="cleanuphtml-1" name="_Toc438322908"> Рисунок </a> <b> 19 </b> <b> Пример разделов данных и кода для тестирования микроассемблерных сборок. </b> <b> <br />
<br /> </b>
</Р>
	<Р>
	Вы можете использовать строчные комментарии, используя символ #. <br />
	Все, что следует за этим символом до конца строки, будет игнорироваться ассемблером.

		Также есть активные комментарии, в которых используются специальные теги для выполнения определенных действий во время выполнения:
                <ul>
                <li>
		<pre class="m-0"># state:</pre>
		 Позволяет сохранить состояние перед выполнением инструкции, предшествующей комментарию.
                </li>
                <li>
		<pre class="m-0"># break:</pre>
		 Позволяет установить точку останова во время выполнения программы.
                </li>
                <li>
		<pre class="m-0">
# notify: skip1st:true showas:offcanvas scroll2current:true
# notify: Lorem ipsum dolor sit amet, consectetur...
                </pre>
		 Позволяет временно остановить выполнение и вывести информацию на боковую панель (offcanvas) или в диалоговое окно (dialogbox).
                </li>
                </ul>
	</Р>

      </DIV>


      <div id="help_simulator_firmware">
      <h1> Управление микрокодами в WepSIM </h1>

<Р>
                На экране «Микрокод» загружается текстовый файл с тремя разделами (микрокод, наименование регистра и определение псевдоинструкций).
Пожалуйста, обратитесь к разделу «Микрокод в WepSIM» для получения дополнительной информации о формате микрокода.
Чтобы получить доступ к этому экрану, вы должны использовать верхнюю центральную кнопку микрокода (см. Рисунок <b class="cleanuphtml-4"> рисунок 16 </b>).
</Р>
<Р>

</Р>
<Р>
<img max-width="90%" width="90%" id="Imagen 1" src="images/simulator/firmware001.jpg" alt="" name="Imagen 1" />
</Р>
<p class="cleanuphtml-2">
<a name="_Ref434190846"> </a> <a name="_Toc438322905"> </a> <a class="cleanuphtml-1" name="_Ref434190877"> Рис. </a> <b> 16 </b> <b> Главный экран: опция для загрузки микрокода. </b>
</Р>
<Р>
<br />
                Затем появляется экран с онлайн-текстовым редактором, где ученик может описать микрокод (три раздела перед комментариями). Пользователи могут загрузить существующий микрокод с помощью кнопки «Загрузить» на верхней панели инструментов, изменить ранее загруженный микрокод или сохранить текущий микрокод с помощью кнопки «Сохранить» на верхней панели инструментов. Когда микрокод будет готов, нажмите кнопку «ilecompile», чтобы микрокомпилировать его, и загрузите полученный двоичный файл в память элемента управления, как показано на <b class="cleanuphtml-4"> Рисунок 17 </b>.
</Р>
<Р>
<img max-width="90%" width="90%" id="Imagen 2" src="images/simulator/firmware002.jpg" alt="" name="Imagen 2" />
</Р>
<p class="MsoNormal cleanuphtml-5"> </p>
<table cellpadding="0" cellspacing="0" align="left">
</table> <br clear="all" />
<p class="cleanuphtml-2">
<a name="_Toc438322906"> </a> <a class="cleanuphtml-1" name="_Ref434191423"> Рисунок </a> <b> 17 </b> <b> Экран микрокода: текстовое поле по порядку загрузить прошивку. </b>
</Р>
<Р>
<br />
                Как только новый микрокод загружен правильно, кнопка, показанная на <b class="cleanuphtml-4"> Рис. 18 </b>, позволяет студентам проверять двоичный файл, загруженный в память управления.
</Р>
<Р>
<img max-width="90%" width="90%" id="Imagen4" src="images/simulator/firmware004.jpg" alt="Кнопка для открытия модальной памяти элемента управления" />
</Р>
<p class="cleanuphtml-2">
<a name="fig4"> </a> <a class="cleanuphtml-1" name="_Ref434191551"> Рисунок </a> <b> 18 </b> <b> Экран микрокода: показать содержимое управляющей памяти . </B>
</Р>
<Р>
<img max-width="90%" width="90%" id="Imagen5" src="images/simulator/firmware005.jpg" alt="Модальный с содержимым управляющей памяти в двоичном виде" />
</Р>
<p class="cleanuphtml-2">
<a name="fig5"> </a> <a class="cleanuphtml-1" name="_Ref434191551"> Рисунок </a> <b> 19 </b> <b> Экран микрокода: двоичный файл в управляющей памяти . </B>
</Р>
<Р>
<br />
                ЗатемШаг ext - загрузить программу на ассемблере для проверки этого микрокода, для этого нужно нажать кнопку «Сборка» на верхней панели инструментов.
Пожалуйста, обратитесь к разделу «Симулятор: сборка» из справки для получения дополнительной информации.
</Р>
<Р>

</Р>

      </DIV>


      <div id="help_simulator_assembly">
      <h1> Управление ассемблером в WepSIM </h1>

<Р>
                Текстовый файл с двумя типами разделов (данные и код) загружается на экран Ассемблера.
                Для доступа к этому экрану студент должен нажать кнопку «Сборка» (см. <B class="cleanuphtml-3"> Рисунок 16 </b>) на верхней панели инструментов.
<br />
</Р>
<Р>
<img max-width="90%" width="90%" id="Imagen 3" src="images/simulator/assembly002.jpg" alt="" name="Imagen 3" />
</Р>
<p class="cleanuphtml-2">
<a name="_Toc438322909"> </a> <a class="cleanuphtml-1" name="_Toc434155501"> Рисунок </a> <b> 20 </b> <b> Главный экран: экран кода ассемблера. </B>
</Р>
<Р>
                Затем появляется текстовый редактор, где код сборки может быть загружен и отредактирован. Вы можете загрузить существующий код с помощью кнопки «Загрузить» на верхней панели, изменить ранее загруженный код или сохранить код, загруженный в данный момент с помощью кнопки «Сохранить» на верхней панели.
</Р>
<Р>
Как только код будет готов, вы должны нажать кнопку «Компилировать», чтобы скомпилировать этот код в двоичный файл и загрузить этот двоичный файл в основную память, как показано на <b class="cleanuphtml-3"> Рисунок 21 </b>.
</Р>
<Р>

</Р>
<Р>
<img max-width="90%" width="90%" id="Imagen 28" src="images/simulator/assembly003.jpg" alt="" name="Imagen 28" />
</Р>
<p class="cleanuphtml-2">
<a name="_Toc438322910"> </a> <a class="cleanuphtml-1" name="_Ref434192102"> Рисунок </a> <b> 21 </b> <b> Экран сборки: текстовый редактор для код сборки. </b> <b> <br />
<br /> </b>
</Р>
<Р>
                После компиляции он перейдет на экран, показанный на <b class="cleanuphtml-3"> Рисунок 22 </b>, и пользователь может нажать на кнопку show, чтобы изучить содержимое основной памяти в двоичном виде (< b class="cleanuphtml-3"> Рисунок 23 </b>).
</Р>
<Р>

</Р>
<Р>
<img max-width="90%" width="90%" id="Imagen 30" src="images/simulator/assembly004.jpg" alt="Экран сборки, кнопка для отображения сборки в двоичном виде" />
</Р>
<p class="cleanuphtml-2">
<a name="_Toc438322912"> </a> <a class="cleanuphtml-1" name="_Ref434192450"> Рисунок </a> <b> 22 </b> <b> Экран сборки: кнопка для просмотра значения основной памяти. </b>
</Р>
<Р>
<img max-width="90%" width="90%" id="Imagen 30" src="images/simulator/assembly005.jpg" alt="Модальный со сборкой в двоичном виде" />
</Р>
<p class="cleanuphtml-2">
<a name="_Toc438322912"> </a> <a class="cleanuphtml-1" name="_Ref434192450"> Рисунок </a> <b> 23 </b> <b> Экран сборки: двоичные значения. </б>
</Р>
<Р>
<br />
                Следующим шагом является возврат к главному экрану для запуска загруженного микрокода и сборки.
                Для этого нужно нажать кнопку «Симулятор» на верхней панели инструментов.
</Р>
<Р>
</Р>

      </DIV>


      <div id="help_simulator_execution">
      <h1> Симуляция в WepSIM </h1>

<Р>
На главном экране можно увидеть:
</Р>
<UL>
<Li>
Содержимое памяти управления (см. <B> Рисунок 24 </b>), с каждым циклом управляющих сигналов.
                Для этого студент должен использовать кнопку «<i> Control Memory </i>» на верхней панели инструментов главного экрана. <br />
                На этой вкладке сигналы текущего цикла подсвечиваются синим цветом (и немного большим шрифтом). <br />
                С помощью правой полосы прокрутки можно проверить содержимое всей памяти управления.
</Li>
<Li>
                Основное содержимое памяти (см. <B class="cleanuphtml-1"> Figure 25 </b>) с инструкцией по сборке, которая должна быть выполнена.
                Можно установить точку останова, щелкнув столбец <i> точки останова </i>.
                Когда точка останова установлена, в этом столбце появится значок «стоп».
</Li>
</UL>
<Р>
<img max-width="90%" width="90%" id="Imagen 1" src="images/simulator/simulator009.jpg" alt="" name="Imagen 1" />
</Р>
<p class="cleanuphtml-3">
<a name="_Toc438322913"> </a> <a class="cleanuphtml-2" name="_Ref434192973"> Рисунок </a> <b> 24 </b> <b> Главный экран: визуализация элемента управления память. </B>
</Р>
<Р>
</Р>
<Р>
<img max-width="90%" width="90%" id="Imagen 3" src="images/simulator/simulator010.jpg" alt="" name="Imagen 3" />
</Р>
<p class="cleanuphtml-3">
<a name="_Toc438322914"> </a> <a class="cleanuphtml-2" name="_Ref434193222"> Рисунок </a> <b> 25 </b> <b> Главный экран: визуализация основного код памяти. </b>
</Р><Р>
</Р>
<Р>
                На главном экране можно выполнить:
</Р>
<Р>
· Микроинструкция с помощью микроинструкции, нажав на кнопку «Instrucci & oacute; n» (см. <B class="cleanuphtml-1»> Figure 26 </b>), чтобы перейти к следующему тактовому циклу и отправить соответствующий элемент управления. сигналы.
</Р>
<Р>
· Инструкция за инструкцией, нажав кнопку «Instrucci & oacute; n» (см. <B class="cleanuphtml-1"> Figure 26 </b>), чтобы сгенерировать все тактовые циклы для микрокода соответствующей инструкции, остановка в начале выборки.
</Р>
<Р>
</Р>
<Р>
<img max-width="90%" width="90%" id="Imagen 4" src="images/simulator/simulator011.jpg" alt="" name="Imagen 4" />
</Р>
<p class="cleanuphtml-3">
<a name="_Toc438322915"> </a> <a class="cleanuphtml-2" name="_Ref434193775"> Рисунок </a> <b> 26 </b> <b> Главный экран: параметры выполнения. </б>
</Р>
<Р>
<br />
С помощью кнопки «<i> Registers </i>» в правой верхней части основного экрана (см. <B class="cleanuphtml-1"> Figure 26 </b>) можно увидеть значения регистр процессора и как они меняются во время исполнения.
</Р>
<Р>
                Также можно увидеть блок управления, как показано на <b class="cleanuphtml-1"> Рисунок 27 </b>.
</Р>
<Р>
</Р>
<Р>
<img max-width="90%" width="90%" id="Imagen 8" src="images/simulator/simulator012.jpg" alt="" name="Imagen 8" />
</Р>
<p class="cleanuphtml-3">
<a name="_Toc438322916"> </a> <a class="cleanuphtml-2" name="_Ref434194139"> Рисунок </a> <b> 27 </b> <b> Главный экран: визуализация блока управления. </B>
</Р>
<Р>
                И также можно сбросить выполнение, нажав на кнопку «Сброс» в верхней панели.
</Р>
<Р>
</Р>
<Р>
</Р>

      </DIV>


      <div id="help_checker">

              Можно проверить, что текущее состояние соответствует нашим требованиям:
<Р>
<UL>
<li> Чтобы проверить текущее состояние, введите требования и нажмите «проверить». </li>
<С>
Например: <br>
<textarea aria-label="проверяет выполнение" row="2">
регистр 5> = 8; память 1 = 0x10; экран 0 == first_line
</TextArea>
</С>
<li> Чтобы очистить требования, нажмите "очистить". </li>
</UL>
<Р>
<b> СОВЕТ: нужны точки с запятой. </b>
<br>
<b> СОВЕТ: будьте осторожны, поскольку полосы прокрутки раньше были скрыты. </b>
<br>
Когда предоставляются пустые требования, исходное состояние принимается во внимание.

      </DIV>


      <div id="help_dumper">

<UL>
<Li>
Панель «Текущее состояние» по умолчанию показывает состояние моделируемой машины (на уровне сборки) в настоящий момент.
Состояние машины - это список элементов аппаратного обеспечения и его значений.
Для упрощения показаны только аппаратные элементы с ненулевыми значениями. <br>
Например: <br>
<textarea aria-label="проверяет выполнение" row="2" class="w-50">
регистр 5> = 8; память 1 = 0x10; экран 0 == first_line
</TextArea>
<br>
              Пожалуйста, запомните две важные детали:
<UL>
<li> <em> Точки с запятой необходимы. </em>
                     ';' символ обозначает конец любой пары ключ = значение. </li>
<li> <em> Полосы прокрутки используются для скрытия текущего состояния и различий. </em> </li>
</UL>

Это «Текущее состояние» можно изменить, скопировать в буфер обмена или сохранить на панели «История».
<Li>
              Панель «Журнал» позволяет пользователям отслеживать состояние при разных тактах процессора.
<Li>
              Панель «Разница» может использоваться для отображения различий между двумя состояниями.
Отображаются только значения, которые отличаются между двумя состояниями.
</UL>

<Р>
<UL>
              Типичные шаги для использования этого диалогового окна показаны в этой анимации: <br>
<img class="w-75" src="help/welcome/states_usage.gif">
</UL>

      </DIV>

  </Body>
</Html>
