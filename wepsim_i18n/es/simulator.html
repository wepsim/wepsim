<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <title></title>
	<meta charset="UTF-8">
	<meta http-equiv="Content-type" content="text/html; charset=UTF-8">
    <style type="text/css">
/*<![CDATA[*/
    :link { color: #0563C1 }
    :visited { color: #954F72 }
    p.cleanuphtml-5 {margin-bottom:8.0pt;line-height:80%}
    b.cleanuphtml-4 {font-style: italic}
    p.cleanuphtml-3 {font-weight: bold}
    p.cleanuphtml-2 {text-align: center}
    a.cleanuphtml-1 {font-weight: bold}
    /*]]>*/
    </style>

  <!-- Clean HTML generated by http://www.cleanuphtml.com/ -->
	<meta name="Generator" content="Cleanup HTML"></head>
  <body>

      <div id="help_firmware_format">
      <h1>Microc&oacute;digo en WepSIM</h1>

	      <p>
	      </p>
	      <p>
	        El microc&oacute;digo se carga a trav&eacute;s de un fichero de texto que tiene tres secciones:
	      </p>
	      <p>
	        1.    Lista de microprogramas
	      </p>
	      <p>
	        2.    Nombrado de registros
	      </p>
	      <p>
	        3.    Pseudo-instrucciones
	      </p>
	      <p>
	        La lista de microprogramas comienza con el c&oacute;digo del <i>fetch</i>.<br />
	        Un ejemplo de microprograma de <b>fetch</b> b&aacute;sico ser&iacute;a:
	      </p>
	      <ul>
	      <p>
	        begin<br>
	        {<br>
	                fetch:    (T2, C0=1),<br>
	                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (Ta, Td, R, BW=11, C1),<br>
	                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (M2, C2, T1, C3),<br>
	                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (A0, B=0, C=0000)<br>
	        }<br>
	      </p>
	      </ul>
	      <p class="cleanuphtml-2">
	        <a class="cleanuphtml-1" name="_Toc438322900">Figura</a> <b>11</b> <b>Ejemplo de descripci&oacute;n para</b> <b>fetch</b>
	      </p>
	      <p>
	        Las se&nacute;ales de control situadas entre los par&eacute;ntesis ( y ) se corresponden con las se&nacute;ales a activar en un ciclo de reloj. As&iacute; el fetch necesita cuatro ciclos de reloj, el &uacute;ltimo se
	        corresponde con la decodificaci&oacute;n (incluida en dentro del fetch).
	      </p>
	      <p>
	        A continuaci&oacute;n se encuentran el resto de microprogramas asociados a cada instrucci&oacute;n. Cada microprograma sigue el siguiente formato:
	      </p>
	      <ul>
	      <p>
	        inst1 campo1 campo2 campo3<br>
	        {<br>
	           &nbsp;&nbsp;&nbsp;&nbsp; co=000000,<br>
	           &nbsp;&nbsp;&nbsp;&nbsp; nwords=1,<br>
	           &nbsp;&nbsp;&nbsp;&nbsp; campo1=reg(25,21),<br>
	           &nbsp;&nbsp;&nbsp;&nbsp; campo2=reg(20,16),<br>
	           &nbsp;&nbsp;&nbsp;&nbsp; campo3=reg(15,11),<br>
	           &nbsp;&nbsp;&nbsp;&nbsp; {<br>
	           &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (Cop=1001, SelP=11, C7, T6, LC, SelA=10100, SelB=01111, SelC=10111,<br>
	           &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  A0=1, B=1, C=0)<br>
	           &nbsp;&nbsp;&nbsp;&nbsp; }<br>
	        }<br>
	      </p>
	      </ul>
	      <p class="cleanuphtml-2">
	        <a class="cleanuphtml-1" name="_Toc438322901">Figura</a> <b>12</b> <b>Ejemplo de formato de descripci&oacute;n de una instrucci&oacute;n</b>
	      </p>
	      <p>
	         
	      </p>
	      <p>
	        Donde la primera l&iacute;nea describe el nombre de la instrucci&oacute;n (inst1) y los par&aacute;metros que tiene (registros, valores inmediatos, etc.). A continuaci&oacute;n se abre un bloque con llaves para
	        describir dicha instrucci&oacute;n.
	      </p>
	      <p>
	        El primer campo del ejemplo mostrado (co) indica los 6 bits que identifica un&iacute;vocamente la instrucci&oacute;n. Esto no es del todo cierto para las instrucciones aritm&eacute;tico-l&oacute;gicas puesto que es
	        posible compartir el mismo c&oacute;digo de operaci&oacute;n y seg&uacute;n el valor del campo cop diferenciarse. Un ejemplo de este caso ser&iacute;a:
	      </p>
	      <ul>
	      <p>
	         
	      </p>
	      <p>
	        inst1 campo1 campo2 campo3<br>
	        {<br>
	            &nbsp;&nbsp;&nbsp;&nbsp; co=000000,<br>
	            &nbsp;&nbsp;&nbsp;&nbsp; <b>cop=00000,</b><br>
	            &nbsp;&nbsp;&nbsp;&nbsp; nwords=1,<br>
	            &nbsp;&nbsp;&nbsp;&nbsp; campo1=reg(25,21),<br>
	            &nbsp;&nbsp;&nbsp;&nbsp; campo2=reg(20,16),<br>
	            &nbsp;&nbsp;&nbsp;&nbsp; campo3=reg(15,11),<br>
	            &nbsp;&nbsp;&nbsp;&nbsp; {<br>
	            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (Cop=1001, SelP=11, C7, T6, LC, SelA=10100, SelB=01111, SelC=10111,<br>
	            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; A0=1, B=1, C=0)<br>
	            &nbsp;&nbsp;&nbsp;&nbsp; }<br>
	        }<br>
	      </p>
	      </ul>
	      <p class="cleanuphtml-2">
	        <a class="cleanuphtml-1" name="_Toc438322902">Figura</a> <b>13</b> <b>Detalle en la descripci&oacute;n de una instrucci&oacute;n: campo cop</b>
	      </p>
	      <p>
	        <br />
	        Los siguientes campos indican para cada uno de los par&aacute;metros qu&eacute; tipo es (registro, inmediato o direcci&oacute;n) as&iacute; como el bit de inicio y final (valor de 0 a 31) entre los cuales est&aacute; el valor de dicho par&aacute;metro.
	      </p>
	      <p>
	        El tipo de par&aacute;metro se indica con:
	      </p>
<ul>
	      <li>
	        parametro1 = reg(bit-final, bit-inicio), <br> para un registro, siendo los 5 bits que identifican el registro a usar.
	      </li>
	      <li>
	        parametro1 = inm(bit-final, bit-inicio), <br> para un valor inmediato.
	      </li>
	      <li>
	        parametro1 = address(bit-final, bit-inicio)rel, <br> para una direcci&oacute;n relativa con respecto al PC.
	      </li>
	      <li>
	        parametro1 = address(bit-final, bit-inicio)abs, <br> para una direcci&oacute;n absoluta.
	      </li>
</ul>
	      <p>
	        A continuaci&oacute;n se abre un bloque donde se indicar&aacute; el microprograma correspondiente a la instrucci&oacute;n. Las se&nacute;ales de cada ciclo est&aacute;n entre par&eacute;ntesis y se separan dichos ciclos por coma. Si
	        solo hay un ciclo no es necesario la coma. Dentro de los par&eacute;ntesis se indicar&aacute;n las se&nacute;ales y el valor correspondiente. Si es una se&nacute;al de un bit, con solo poner el nombre de la se&nacute;al se
	        entender&aacute; que su valor es uno. El valor de la se&nacute;al se ha de indicar en binario, usando tantos bits como tenga asociado la se&nacute;al. Las se&nacute;ales y su valor correspondientes se separan usando una
	        coma.
	      </p>
	      <p>
	        Para el nombrado de registros se precisa indicar la etiqueta que se usar&aacute; para cada uno de los 32 registros del banco de registros. Un ejemplo de esta secci&oacute;n es:<br />
	        <br />
	      </p>
	      <ul>
	      <p>
	        registers
	      </p>
	      <p>
	        { <br>
	                  0=($zero, $0), <br>
	                  1=($at, $1), <br>
	                  2=($v0, $2), <br>
	                  3=($v1, $3), <br>
	                  4=($a0, $4), <br>
	                  5=($a1, $5), <br>
	                  6=($a2, $6), <br>
	                  7=($a3, $7), <br>
	                  .  <br>
	                  .  <br>
	                  .  <br>
	                  24=($t8, $24), <br>
	                  25=($t9, $25), <br>
	                  26=($k0, $26), <br>
	                  27=($k1, $27), <br>
	                  28=($gp, $28), <br>
	                  29=($sp, $29) (stack_pointer), <br>
	                  30=($fp, $30), <br>
	                  31=($ra, $31)  <br>
	        }
	      </p>
	      </ul>
	      <p class="cleanuphtml-2">
	        <a class="cleanuphtml-1" name="_Toc438322903">Figura</a> <b>14</b> <b>Ejemplo de nombrado de registros</b>
	      </p>
	      <p>
	        <br />
	        En la que se indican los nombres usados en la arquitectura MIPS32. En este ejemplo el registro 29 etiquetado con $sp tiene el atributo "(stack_pointer)" para indicar que ser&aacute; usado como
	        puntero de pila.
	      </p>
	      <p>
	         
	      </p>
	      <p>
	        Por &uacute;ltimo es posible definir pseudo-instrucciones.<br />
	        Un ejemplo de pseudoinstrucci&oacute;n ser&iacute;a:
	      </p>
	      <ul>
	      <p>
	        Pseudoinstructions<br />
	        {<br />
	                li reg1=reg num=inm<br />
	                {<br />
	                       lui reg1 sel(31,16,num) ;<br />
	                       ori reg1 reg1 sel(15,0,num)<br />
	                 }<br />
	        }
	      </p>
	      <p>
	         
	      </p>
	      </ul>
	      <p class="cleanuphtml-2">
	        <a class="cleanuphtml-1" name="_Toc438322904">Figura</a> <b>15</b> <b>Ejemplo de pseudo-instrucci&oacute;n (secci&oacute;n opcional)</b>
	      </p>
	      <p>
	        <br />
	        Donde el operador "sel(bit-inicio, bit-final, campo)" permite seleccionar una serie de bits de uno de los campos de la pseudo-instrucci&oacute;n.
	      </p>


<br />
<h3>Resumen con ejemplo</h3>
<center>
<table class="table table-hover table-bordered table-sm"
       cellpadding="2" cellspacing="2" border="1">
<thead>
  <tr>
    <th>Section</th>
    <th>Firmware version 1</th>
    <th>Firmware version 2</th>
  </tr>
</thead>

<tbody>
<tr>
<td rowspan="2">1. List of microprograms</td>
<td>
<pre>


 begin
 {
   fetch: (T2, C0=1),
          (Ta, Td, R, BW=11, C1),
          (M2, C2, T1, C3),
          (A0, B=0, C=0000)
 }
</pre>
</td>
<td>
<pre>
 <b>firmware_version=2</b>

 begin
 {
   fetch: (T2, C0=1),
          (Ta, Td, R, BW=11, C1),
          (M2, C2, T1, C3),
          (A0, B=0, C=0000)
 }
</pre>
</td>
</tr>
<tr>
<td>
<pre>
inst1 field1 field2 field3
{
     co=000000,
     cop=00000,
     nwords=1,
     field1=reg(25,21),
     field2=inm(20,16),
     field3=address(15,11)rel,
     {
        (Cop=1001, SelP=11, C7),
        (A0=1, B=1, C=0)
     }
}
</pre>
</td>
<td>
<pre>
inst1 field1 field2 field3
{
   <b>nwords=1,
   co(31,27)=000000,
   funct(10,8)=000,
   reg(25,21)=field1,
   inm(20,16)=field2,
   address-rel(15,11)=field3,</b>
   {
      (Cop=1001, SelP=11, C7),
      (A0=1, B=1, C=0)
   }
}
</pre>
</td>
</tr>

<tr>
<td>2. Register naming</td>
<td>
<pre>
registers
{
  0=($zero, $0),
  1=($at, $1),
  .
  .
  28=($gp, $28),
  29=($sp, $29) (stack_pointer),
  30=($fp, $30),
  31=($ra, $31)
}
</pre>
</td>
<td>
<pre>
registers
{
  0=($zero, $0),
  1=($at, $1),
  .
  .
  28=($gp, $28),
  29=($sp, $29) (stack_pointer),
  30=($fp, $30),
  31=($ra, $31)
}
</pre>
</td>
</tr>

<tr>
<td>3. Pseudo-instructions</td>
<td>
<pre>
pseudoinstructions
{
  li reg1=reg num=inm
  {
     lui reg1 sel(31,16,num) ;
     ori reg1 reg1 sel(15,0,num)
  }
}
</pre>
</td>
<td>
<pre>
pseudoinstructions
{
  li reg1=reg num=inm
  {
     lui reg1 sel(31,16,num) ;
     ori reg1 reg1 sel(15,0,num)
  }
}
</pre>
</td>
</tr>
</tbody>
</table>
</center>


      </div>


      <div id="help_assembly_format">
      <h1>Ensamblador en WepSIM</h1>

	      <p>
	      </p>
	      <p>
	        El c&oacute;digo en ensamblador se describe en un fichero de texto con una primera secci&oacute;n de datos (.data) y una segunda secci&oacute;n para el c&oacute;digo (.text)<br />
	        <br />
	        En la secci&oacute;n de datos es posible definir las variables y constantes que se alojar&aacute;n en el segmento de datos de la memoria principal. Dicha secci&oacute;n comienza con la directiva <i>.data</i>. Las
	        directivas que permiten especificar los distintos tipos de datos que pueden definirse son:
	      </p>
	      <p>
	        &middot;       <b>.ascii:</b> va seguida de la cadena de caracteres, instruyendo al ensamblador para crear una zona de memoria con datos, y almacenar en ella la cadena que se indique.
	      </p>
	      <p>
	        &middot;       <b>.asciiz:</b> va seguida de la cadena de caracteres, instruyendo al ensamblador para crear una zona de memoria con datos, y almacenar en ella la cadena que se muestra terminado por
	        un byte con valor cero.
	      </p>
	      <p>
	        &middot;       <b>.byte:</b> va seguida de uno o m&aacute;s valores que formar&aacute;n parte del valor de la variable. En caso de varios valores, dichos valores se separar&aacute;n por coma. Para los valores se puede
	        usar: <b>car&aacute;cter, octal, hexadecimal y decimal</b>.
	      </p>
	      <p>
	        &middot;       <b>.half:</b> va seguida de uno o m&aacute;s valores que formar&aacute;n parte del valor de la variable. En caso de varios valores, dichos valores se separar&aacute;n por coma.<br />
	        Para los valores se puede usar: <b>octal, hexadecimal y decimal.</b>
	      </p>
	      <p>
	        &middot;       <b>.word:</b> va seguida de uno o m&aacute;s valores que formar&aacute;n parte del valor de la variable. En caso de varios valores, dichos valores se separar&aacute;n por coma.<br />
	        Para los valores se puede usar: <b>octal, hexadecimal y decimal.</b>
	      </p>
	      <p>
	        &middot;       <b>.space:</b> va seguida del n&uacute;mero de bytes, en formato decimal, que el usuario desea reservar en memoria.
	      </p>
	      <p>
	        El formato de un valor de los tipos de datos comentados es:
	      </p>
	      <p>
	        &middot;       <b>Cadena de caracteres:</b> secuencia de caracteres entre comillas dobles.<br />
	        Por ejemplo: "hola 123\n"
	      </p>
	      <p>
	        &middot;       <b>Car&aacute;cter:</b> car&aacute;cter entre comillas simples.<br />
	        Por ejemplo: &apos;c&apos;.
	      </p>
	      <p>
	        &middot;       <b>Octal:</b> un n&uacute;mero que comienza por cero y sus d&iacute;gitos son menores que ocho. Por ejemplo: 012.
	      </p>
	      <p>
	        &middot;       <b>Hexadecimal:</b> un n&uacute;mero que comienza por el prefijo 0x y sus d&iacute;gitos son del cero al nueve y las letras a, b, c, d, e y f.<br />
	        Por ejemplo: 0x12.
	      </p>
	      <p>
	        &middot;       <b>Decimal:</b> un n&uacute;mero que no est&aacute; en formato octal o hexadecimal con d&iacute;gitos comprendidos entre el cero y el nueve (ambos incluidos).<br />
	        Por ejemplo: 12.
	      </p>
	      <p>
	        En la secci&oacute;n de c&oacute;digo es posible definir las subrutinas que se alojar&aacute;n en el segmento de c&oacute;digo de la memoria principal. Dicha secci&oacute;n comienza con la directiva <i>.text</i>.
	      </p>
	      <p>
	         
	      </p>
	      <p>
	        Un ejemplo programa ser&iacute;a:
	      </p>
	      <ul>

<pre class="font-monospace">
.data
  age1:      .word 0x12345678, 20 
  alter2:    .word 20, 10 
  resultado: .word 0 
  # Palabra de 32 bits inicializada con un decimal
  texto:     .ascii  "Hola \t" 
  texto2:    .asciiz "Hola \t" 
  hueco:     .space 16 

.text 
.globl main 
 main: li $3 2 
       li $4 1 
       li $5 0 
</pre>

	      </ul>
	      <p class="cleanuphtml-2">
	        <a class="cleanuphtml-1" name="_Toc438322908">Figura</a> <b>19</b> <b>Ejemplo de secciones de dato y c&oacute;digo en ensamblador para probar microc&oacute;digos</b><b><br />
	        <br /></b>
	      </p>
	      <p>
	        Es posible usar comentarios de l&iacute;nea usando el car&aacute;cter #<br />
	        Todo lo que hay a continuaci&oacute;n de este car&aacute;cter hasta el final de l&iacute;nea ser&aacute; ignorado por el ensamblador.

		También hay comentarios activos que son comentarios con etiquetas especiales que se usan para realizar acciones durante la ejecución:
                <ul>
                <li>
		<pre class="m-0"># state:</pre>
		 Permite salvar el estado antes de ejecutar las instrucciones que precede.
                </li>
                <li>
		<pre class="m-0"># break:</pre>
		 Permite poner un punto de ruptura.
                </li>
                <li>
		<pre class="m-0">
# notify: skip1st:true showas:offcanvas scroll2current:true
# notify: Lorem ipsum dolor sit amet, consectetur...
                </pre>
                 Permite parar la ejecución temporalmente y mostrar una información en un panel lateral (offcanvas) o en un cuadro de dialogo (dialogbox).
                </li>
                </ul>
	      </p>

      </div>


      <div id="help_simulator_firmware">
      <h1>Gesti&oacute;n de microc&oacute;digo en WepSIM</h1>

	      <p>
	        Un fichero de texto con tres secciones (microc&oacute;digo, nombrado de registro y definici&oacute;n de pseudo-instrucciones) se carga en la pantalla de Firmware. 
		Por favor revise 'Microcódigo en WepSIM' para más información sobre el formato del microcódigo.
		Para acceder a dicha pantalla se ha de ir al men&uacute; (parte superior derecha) e indicar la opci&oacute;n <i>Firmware</i> (v&eacute;ase la <b class="cleanuphtml-4">Figura 16</b>)
	      </p>
	      <p>
	         
	      </p>
	      <p>
	        <img max-width="90%" width="90%" id="Imagen 1" src="images/simulator/firmware001.jpg" alt="" name="Imagen 1" />
	      </p>
	      <p class="cleanuphtml-2">
	        <a name="_Ref434190846"></a><a name="_Toc438322905"></a><a class="cleanuphtml-1" name="_Ref434190877">Figura</a> <b>16</b> <b>Pantalla principal: opci&oacute;n de carga de firmware</b>
	      </p>
	      <p>
	        <br />
	        A continuaci&oacute;n aparecer&aacute; una pantalla con un editor de texto en línea que permite indicar el <i>firmware</i> (las tres secciones antes comentadas). Es posible cargar un <i>firmware</i> existente
	        usando el bot&oacute;n "Load" de la barra inferior, modificar un <i>firmware</i> anteriormente cargado o salvar el firmware en curso con el bot&oacute;n "Save" de la barra inferior. Una vez se indique el
	        firmware es preciso hacer clic en el bot&oacute;n "&#181;compile" para pasar a binario y cargar en la memoria de control dicho firmware, como se muestra en la <b class="cleanuphtml-4">Figura 17</b>.
	      </p>
	      <p>
	        <img max-width="90%" width="90%" id="Imagen 2" src="images/simulator/firmware002.jpg" alt="" name="Imagen 2" />
	      </p>
	      <p class="MsoNormal cleanuphtml-5"></p>
	      <table cellpadding="0" cellspacing="0" align="left">
	      </table> <br clear="all" />
	      <p class="cleanuphtml-2">
	        <a name="_Toc438322906"></a><a class="cleanuphtml-1" name="_Ref434191423">Figura</a> <b>17</b> <b>Pantalla firmware: cuadro de texto con firmware a cargar</b>
	      </p>
	      <p>
	        <br />
	        Una vez cargado el nuevo <i>firmware</i> correctamente aparecer&aacute; la pantalla mostrada en la <b class="cleanuphtml-4">Figura 18</b> donde se puede hacer click en el botón indicado para que se muestra la memoria de control con los valores que almacena (<b class="cleanuphtml-4">Figura 19</b>).
	      </p>
	      <p>
	        <img max-width="90%" width="90%" id="Imagen4" src="images/simulator/firmware004.jpg" alt="botón de mostrar la memoria de control" name="Imagen4" />
	      </p>
	      <p class="cleanuphtml-2">
	        <a name="_Toc438322907"></a><a class="cleanuphtml-1" name="_Ref434191551">Figura</a> <b>18</b> <b>Pantalla firmware: botón para mostrar la memoria de control</b>
	      </p>

	      <p>
	        <img max-width="90%" width="90%" id="Imagen5" src="images/simulator/firmware005.jpg" alt="modal con el contenido de la memoria de control" name="Imagen5" />
	      </p>
	      <p class="cleanuphtml-2">
	        <a name="_Toc438322907"></a><a class="cleanuphtml-1" name="_Ref434191551">Figura</a> <b>19</b> <b>Pantalla firmware: firmware finalmente compilado</b>
	      </p>
	      <p>
	        <br />
	        El siguiente paso es la carga del programa ensamblador que permita probar este <i>firmware</i>, para ello podemos pulsar el bot&oacute;n "<i>Assembly</i>" de la barra inferior.
		Por favor revise la sección 'Simulador: ensamblador' para más información al respecto.
	      </p>
	      <p>
	         
	      </p>

      </div>


      <div id="help_simulator_assembly">
      <h1>Gesti&oacute;n del ensamblador en WepSIM</h1>

	      <p>
	        Un fichero de texto con dos tipos de secciones (datos y c&oacute;digo) se carga en la pantalla de Ensamblador. 
		Para acceder a dicha pantalla se ha de ir al men&uacute; (parte superior derecha)
	        e indicar la opci&oacute;n Assembly (v&eacute;ase la <b class="cleanuphtml-3">Figura 20</b>)<br />
	        <br />
	      </p>
	      <p>
	        <img max-width="90%" width="90%" id="Imagen 3" src="images/simulator/assembly002.jpg" alt="" name="Imagen 3" />
	      </p>
	      <p class="cleanuphtml-2">
	        <a name="_Toc438322909"></a><a class="cleanuphtml-1" name="_Toc434155501">Figura</a> <b>20</b> <b>Pantalla principal: opci&oacute;n de carga de c&oacute;digo ensamblador</b>
	      </p>
	      <p>
	        A continuaci&oacute;n aparecer&aacute; una pantalla con un editor de texto que permite indicar el c&oacute;digo en ensamblador. Es posible cargar un c&oacute;digo existente usando el bot&oacute;n "Load" de la barra superior,
	        modificar un c&oacute;digo anteriormente cargado o salvar el c&oacute;digo actualmente en cargado con el bot&oacute;n "Save" de la barra inferior.
	      </p>
	      <p>
	        Una vez se indique el c&oacute;digo es preciso hacer clic en el bot&oacute;n "Compile" para pasar a binario y cargar en la memoria de principal el binario resultante, 
		tal y como se muestra en la <b class="cleanuphtml-3">Figura 21</b>. 
	      </p>
	      <p>
	         
	      </p>
	      <p>
	        <img max-width="90%" width="90%" id="Imagen 28" src="images/simulator/assembly003.jpg" alt="" name="Imagen 28" />
	      </p>
	      <p class="cleanuphtml-2">
	        <a name="_Toc438322910"></a><a class="cleanuphtml-1" name="_Ref434192102">Figura</a> <b>21</b> <b>Pantalla ensamblador: cuadro de texto con ensamblador a cargar</b><b><br />
	        <br /></b>
	      </p>
	      <p>
	        Una vez compilado, se pasar&aacute; a la pantalla indicada en la <b class="cleanuphtml-3">Figura 22</b>, desde donde se puede hacer click en el botón mostrado para mostrar el contenido de la memoria principal en binario (<b class="cleanuphtml-3">Figura 23</b>).
	      </p>
	      <p>
	      </p>
	      <p>
	        <img max-width="90%" width="90%" id="Imagen 30" src="images/simulator/assembly004.jpg" alt="botón para solicitar explorar la memoria principal" />
	      </p>
	      <p class="cleanuphtml-2">
	        <a name="_Toc438322912"></a><a class="cleanuphtml-1" name="_Ref434192450">Figura</a> <b>22</b> <b>Pantalla ensamblador: botón para explorar la memoria principal</b>
	      </p>
	      <p>
	        <img max-width="90%" width="90%" id="Imagen 30" src="images/simulator/assembly005.jpg" alt="memoria principal en binario" />
	      </p>
	      <p class="cleanuphtml-2">
	        <a name="_Toc438322912"></a><a class="cleanuphtml-1" name="_Ref434192450">Figura</a> <b>23</b> <b>Pantalla ensamblador: c&oacute;digo finalmente compilado</b>
	      </p>
	      <p>
	        <br />
	        El siguiente paso es ir a la pantalla principal para ejecutar la combinaci&oacute;n de <i>firmware</i> y ensamblador cargado, para lo que ha de pulsar el bot&oacute;n "Simulador" de la barra inferior.
	      </p>
	      <p>
	      </p>

      </div>


      <div id="help_simulator_execution">
      <h1>Simulaci&oacute;n en WepSIM</h1>

	      <p>
	        Estando en la pantalla principal es posible visualizar:
	      </p>
	      <ul>
	      <li>
	        El contenido de la memoria de control (v&eacute;ase la <b>Figura 24</b>), con las se&ntilde;ales que est&aacute;n asociadas a cada ciclo. Para ello ha de pulsar el bot&oacute;n "<i>Control Memory</i>" en
	        la barra de botones situada en la parte superior derecha de la pantalla principal.<br />
	        Se destaca las se&ntilde;ales que en el presente ciclo de reloj est&aacute;n activadas en azul con letra algo m&aacute;s grande.<br />
	        Se dispone de una barra de desplazamiento para poder inspeccionar todo el contenido de la memoria de control.
	      </li>
	      <li>
	        El contenido de la memoria principal (v&eacute;ase la <b class="cleanuphtml-1">Figura 25</b>), con las instrucciones en ensamblador a ejecutar. Para estas, es posible establecer un punto de
	        ruptura haciendo clic en la columna <i>breakpoints</i>. Al establecer un punto de ruptura aparecer&aacute; un icono en dicha columna.
	      </li>
	      </ul>
	      <p>
	        <img max-width="90%" width="90%" id="Imagen 1" src="images/simulator/simulator009.jpg" alt="" name="Imagen 1" />
	      </p>
	      <p class="cleanuphtml-3">
	        <a name="_Toc438322913"></a><a class="cleanuphtml-2" name="_Ref434192973">Figura</a> <b>24</b> <b>Pantalla principal: visualizaci&oacute;n de la memoria de control</b>
	      </p>
	      <p>
	      </p>
	      <p>
	        <img max-width="90%" width="90%" id="Imagen 3" src="images/simulator/simulator010.jpg" alt="" name="Imagen 3" />
	      </p>
	      <p class="cleanuphtml-3">
	        <a name="_Toc438322914"></a><a class="cleanuphtml-2" name="_Ref434193222">Figura</a> <b>25</b> <b>Pantalla principal: visualizaci&oacute;n del c&oacute;digo en la memoria principal</b>
	      </p>
	      <p>
	      </p>
	      <p>
	        Estando en la pantalla principal es posible ejecutar:
	      </p>
	      <p>
	        ·       Microinstrucci&oacute;n a microinstrucci&oacute;n pulsando el bot&oacute;n "µInstrucci&oacute;n" (v&eacute;ase la <b class="cleanuphtml-1">Figura 26</b>), de forma que se pasar&aacute; al siguiente ciclo de reloj y se
	        generar&aacute;n las se&ntilde;ales de control asociadas.
	      </p>
	      <p>
	        ·       Instrucci&oacute;n a instrucci&oacute;n pulsando el bot&oacute;n "Instrucci&oacute;n" (v&eacute;ase la <b class="cleanuphtml-1">Figura 26</b>) de forma que se generar&aacute;n todos los ciclos de reloj asociados al
	        microprograma de la instrucci&oacute;n, parando al principio del <i>fetch</i>.
	      </p>
	      <p>
	      </p>
	      <p>
	        <img max-width="90%" width="90%" id="Imagen 4" src="images/simulator/simulator011.jpg" alt="" name="Imagen 4" />
	      </p>
	      <p class="cleanuphtml-3">
	        <a name="_Toc438322915"></a><a class="cleanuphtml-2" name="_Ref434193775">Figura</a> <b>26</b> <b>Pantalla principal: opciones para la ejecuci&oacute;n</b>
	      </p>
	      <p>
	        <br />
	        Dando al bot&oacute;n "<i>Registers</i>" en la barra de botones situada en la parte superior derecha de la pantalla principal (v&eacute;ase la <b class="cleanuphtml-1">Figura 26</b>) es posible ver c&oacute;mo
	        los valores de los registros son modificados durante la ejecuci&oacute;n.
	      </p>
	      <p>
	        Es posible visualizar tambi&eacute;n la unidad de control como se muestra en la <b class="cleanuphtml-1">Figura 27</b>.
	      </p>
	      <p>
	      </p>
	      <p>
	        <img max-width="90%" width="90%" id="Imagen 8" src="images/simulator/simulator012.jpg" alt="" name="Imagen 8" />
	      </p>
	      <p class="cleanuphtml-3">
	        <a name="_Toc438322916"></a><a class="cleanuphtml-2" name="_Ref434194139">Figura</a> <b>27</b> <b>Pantalla principal: visualizaci&oacute;n de la unidad de control</b>
	      </p>
	      <p>
	        As&iacute; como tambi&eacute;n es posible reiniciar la ejecuci&oacute;n haciendo clic al bot&oacute;n "Reset" situado en la barra de botones que aparece en la parte superior de la pantalla.
	      </p>
	      <p>
	      </p>
	      <p>
	      </p>

      </div>


      <div id="help_checker">

              Es posible comprobar que el estado actual cumple los requisitos deseados:
	      <p>
	      <ul>
	        <li>Para comprobar el estado actual, por favor introduzca los requisitos y presione "check".</li>
	        <c>
	        Por ejemplo:<br>
	        <textarea aria-label="checks to perform" rows="2">
register 5 >= 8 ; memory 1 = 0x10; screen 0 == first_line
	        </textarea>
	        </c>
	        <li>Para limpiar los requisitos, presione "clean".</li>
	      </ul>
	      <p>
	      <b>NOTA: los puntos y coma son necesarios.</b>
	      <br>
	      <b>NOTA: tenga cuidado porque las barras de scroll suelen estar ocultas.</b>
	      <br>
	      Cuando no se indican requisitos, se toma el estado inicial como base de comparación.

      </div>


      <div id="help_dumper">

	      <ul>
	      <li>
              El panel 'Current state' muestra por defecto el estado actual de la m&aacute;quina simulada (el estado visible por el programador en ensamblador).
	      El estado de la m&aacute; simulada es una lista de los distintos elementos del hardware y su valor asociado.
	      Para simplificar, esta lista se define como los valores que no son cero.
              Por defecto toda posición de memoria, valor de registro, etc. vale cero (y no se muestra),
	      pero los valores que sean distintos de cero son mostrados en el panel.<br>
	      Por ejemplo:<br>
	        <textarea aria-label="checks to perform" rows="2" class="w-50">
register 5 >= 8 ; memory 1 = 0x10; screen 0 == first_line
	        </textarea>
	      <br>
	      <ul>
                Por favor recuerde dos detalles importantes:
	        <li><em>Los puntos y coma son necesarios como separador de requisitos.</em></li>
	        <li><em>Tenga cuidado porque las barras de scroll suelen estar ocultas.</em></li>
	      </ul>

	      Este 'Estado actual' puede modificarse, copiarse al portapapeles o almacenarse en el panel de 'Historial'.
	      <li>
              El panel 'History' permite a los usuarios llevar la pista de los estados en diferentes ciclos de reloj de CPU.
	      <li>
              El panel de 'Difference' permite mostrar las diferencias entre dos estados.
              Solo se muestran los valores distintos entre dos estados.
	      </ul>

	      <p>
	      <ul>
              Los pasos t&iacute;picos para el uso se muestran en la siguiente animaci&oacute;n:<br>
	      <img class="w-75" src="images/welcome/states_usage.gif">
	      </ul>

      </div>

  </body>
</html>
