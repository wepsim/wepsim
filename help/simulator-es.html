<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <title></title>
	<meta charset="UTF-8">
	<meta http-equiv="Content-type" content="text/html; charset=UTF-8">
    <style type="text/css">
/*<![CDATA[*/
    :link { color: #0563C1 }
    :visited { color: #954F72 }
    p.cleanuphtml-5 {margin-bottom:8.0pt;line-height:80%}
    b.cleanuphtml-4 {font-style: italic}
    p.cleanuphtml-3 {font-weight: bold}
    p.cleanuphtml-2 {text-align: center}
    a.cleanuphtml-1 {font-weight: bold}
    /*]]>*/
    </style>

  <!-- Clean HTML generated by http://www.cleanuphtml.com/ -->
	<meta name="Generator" content="Cleanup HTML"></head>
  <body>

      <div id="help_firmware_format">
      <h1>Microc&oacute;digo en WepSIM</h1>

	      <p>
	      </p>
	      <p>
	        El microc&oacute;digo se carga a trav&eacute;s de un fichero de texto que tiene tres secciones:
	      </p>
	      <p>
	        1.    Lista de microprogramas
	      </p>
	      <p>
	        2.    Nombrado de registros
	      </p>
	      <p>
	        3.    Pseudo-instrucciones
	      </p>
	      <p>
	        La lista de microprogramas comienza con el c&oacute;digo del <i>fetch</i>.<br />
	        Un ejemplo de microprograma de <b>fetch</b> b&aacute;sico ser&iacute;a:
	      </p>
	      <ul>
	      <p>
	        begin<br>
	        {<br>
	                fetch:    (T2, C0=1),<br>
	                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (Ta, Td, R, BW=11, C1),<br>
	                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (M2, C2, T1, C3),<br>
	                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (A0, B=0, C=0000)<br>
	        }<br>
	      </p>
	      </ul>
	      <p class="cleanuphtml-2">
	        <a class="cleanuphtml-1" name="_Toc438322900">Figura</a> <b>11</b> <b>Ejemplo de descripci&oacute;n para</b> <b>fetch</b>
	      </p>
	      <p>
	        Las se&nacute;ales de control situadas entre los par&eacute;ntesis ( y ) se corresponden con las se&nacute;ales a activar en un ciclo de reloj. As&iacute; el fetch necesita cuatro ciclos de reloj, el &uacute;ltimo se
	        corresponde con la decodificaci&oacute;n (incluida en dentro del fetch).
	      </p>
	      <p>
	        A continuaci&oacute;n se encuentran el resto de microprogramas asociados a cada instrucci&oacute;n. Cada microprograma sigue el siguiente formato:
	      </p>
	      <ul>
	      <p>
	        inst1 campo1 campo2 campo3<br>
	        {<br>
	           &nbsp;&nbsp;&nbsp;&nbsp; co=000000,<br>
	           &nbsp;&nbsp;&nbsp;&nbsp; nwords=1,<br>
	           &nbsp;&nbsp;&nbsp;&nbsp; campo1=reg(25,21),<br>
	           &nbsp;&nbsp;&nbsp;&nbsp; campo2=reg(20,16),<br>
	           &nbsp;&nbsp;&nbsp;&nbsp; campo3=reg(15,11),<br>
	           &nbsp;&nbsp;&nbsp;&nbsp; {<br>
	           &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (Cop=1001, SelP=11, C7, T6, LC, SelA=10100, SelB=01111, SelC=10111,<br>
	           &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  A0=1, B=1, C=0)<br>
	           &nbsp;&nbsp;&nbsp;&nbsp; }<br>
	        }<br>
	      </p>
	      </ul>
	      <p class="cleanuphtml-2">
	        <a class="cleanuphtml-1" name="_Toc438322901">Figura</a> <b>12</b> <b>Ejemplo de formato de descripci&oacute;n de una instrucci&oacute;n</b>
	      </p>
	      <p>
	         
	      </p>
	      <p>
	        Donde la primera l&iacute;nea describe el nombre de la instrucci&oacute;n (inst1) y los par&aacute;metros que tiene (registros, valores inmediatos, etc.). A continuaci&oacute;n se abre un bloque con llaves para
	        describir dicha instrucci&oacute;n.
	      </p>
	      <p>
	        El primer campo del ejemplo mostrado (co) indica los 6 bits que identifica un&iacute;vocamente la instrucci&oacute;n. Esto no es del todo cierto para las instrucciones aritm&eacute;tico-l&oacute;gicas puesto que es
	        posible compartir el mismo c&oacute;digo de operaci&oacute;n y seg&uacute;n el valor del campo cop diferenciarse. Un ejemplo de este caso ser&iacute;a:
	      </p>
	      <ul>
	      <p>
	         
	      </p>
	      <p>
	        inst1 campo1 campo2 campo3<br>
	        {<br>
	            &nbsp;&nbsp;&nbsp;&nbsp; co=000000,<br>
	            &nbsp;&nbsp;&nbsp;&nbsp; <b>cop=0000,</b><br>
	            &nbsp;&nbsp;&nbsp;&nbsp; nwords=1,<br>
	            &nbsp;&nbsp;&nbsp;&nbsp; campo1=reg(25,21),<br>
	            &nbsp;&nbsp;&nbsp;&nbsp; campo2=reg(20,16),<br>
	            &nbsp;&nbsp;&nbsp;&nbsp; campo3=reg(15,11),<br>
	            &nbsp;&nbsp;&nbsp;&nbsp; {<br>
	            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (Cop=1001, SelP=11, C7, T6, LC, SelA=10100, SelB=01111, SelC=10111,<br>
	            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; A0=1, B=1, C=0)<br>
	            &nbsp;&nbsp;&nbsp;&nbsp; }<br>
	        }<br>
	      </p>
	      </ul>
	      <p class="cleanuphtml-2">
	        <a class="cleanuphtml-1" name="_Toc438322902">Figura</a> <b>13</b> <b>Detalle en la descripci&oacute;n de una instrucci&oacute;n: campo cop</b>
	      </p>
	      <p>
	        <br />
	        Los siguientes campos indican para cada uno de los par&aacute;metros qu&eacute; tipo es (registro, inmediato o direcci&oacute;n) as&iacute; como el bit de inicio y final (valor de 0 a 31) entre los cuales est&aacute; el valor de dicho par&aacute;metro.
	      </p>
	      <p>
	        El tipo de par&aacute;metro se indica con:
	      </p>
<ul>
	      <li>
	        parametro1 = reg(bit-final, bit-inicio), <br> para un registro, siendo los 5 bits que identifican el registro a usar.
	      </li>
	      <li>
	        parametro1 = inm(bit-final, bit-inicio), <br> para un valor inmediato.
	      </li>
	      <li>
	        parametro1 = addr(bit-final, bit-inicio)rel, <br> para una direcci&oacute;n relativa con respecto al PC.
	      </li>
	      <li>
	        parametro1 = addr(bit-final, bit-inicio)abs, <br> para una direcci&oacute;n absoluta.
	      </li>
</ul>
	      <p>
	        A continuaci&oacute;n se abre un bloque donde se indicar&aacute; el microprograma correspondiente a la instrucci&oacute;n. Las se&nacute;ales de cada ciclo est&aacute;n entre par&eacute;ntesis y se separan dichos ciclos por coma. Si
	        solo hay un ciclo no es necesario la coma. Dentro de los par&eacute;ntesis se indicar&aacute;n las se&nacute;ales y el valor correspondiente. Si es una se&nacute;al de un bit, con solo poner el nombre de la se&nacute;al se
	        entender&aacute; que su valor es uno. El valor de la se&nacute;al se ha de indicar en binario, usando tantos bits como tenga asociado la se&nacute;al. Las se&nacute;ales y su valor correspondientes se separan usando una
	        coma.
	      </p>
	      <p>
	        Para el nombrado de registros se precisa indicar la etiqueta que se usar&aacute; para cada uno de los 32 registros del banco de registros. Un ejemplo de esta secci&oacute;n es:<br />
	        <br />
	      </p>
	      <ul>
	      <p>
	        registers
	      </p>
	      <p>
	        {
	      <br>
	                  0=$zero,
	      <br>
	                  1=$at,
	      <br>
	                  2=$v0,
	      <br>
	                  3=$v1,
	      <br>
	                  4=$a0,
	      <br>
	                  5=$a1,
	      <br>
	                  6=$a2,
	      <br>
	                  7=$a3,
	      <br>
	                  .
	      <br>
	                  .
	      <br>
	                  .
	      <br>
	                  24=$t8,        
	      <br>
	                  25=$t9,
	      <br>
	                  26=$k0,
	      <br>
	                  27=$k1,
	      <br>
	                  28=$gp,
	      <br>
	                  29=$sp (stack_pointer),
	      <br>
	                  30=$fp,
	      <br>
	                  31=$ra
	      <br>
	        }
	      </p>
	      </ul>
	      <p class="cleanuphtml-2">
	        <a class="cleanuphtml-1" name="_Toc438322903">Figura</a> <b>14</b> <b>Ejemplo de nombrado de registros</b>
	      </p>
	      <p>
	        <br />
	        En la que se indican los nombres usados en la arquitectura MIPS32. En este ejemplo el registro 29 etiquetado con $sp tiene el atributo "(stack_pointer)" para indicar que ser&aacute; usado como
	        puntero de pila.
	      </p>
	      <p>
	         
	      </p>
	      <p>
	        Por &uacute;ltimo es posible definir pseudo-instrucciones.<br />
	        Un ejemplo de pseudoinstrucci&oacute;n ser&iacute;a:
	      </p>
	      <ul>
	      <p>
	        Pseudoinstructions<br />
	        {<br />
	                li reg num<br />
	                {<br />
	                       lui reg sel(31,16,num) ;<br />
	                       ori reg reg sel(15,0,num)<br />
	                 }<br />
	        }
	      </p>
	      <p>
	         
	      </p>
	      </ul>
	      <p class="cleanuphtml-2">
	        <a class="cleanuphtml-1" name="_Toc438322904">Figura</a> <b>15</b> <b>Ejemplo de pseudo-instrucci&oacute;n (secci&oacute;n opcional)</b>
	      </p>
	      <p>
	        <br />
	        Donde el operador "sel(bit-inicio, bit-final, campo)" permite seleccionar una serie de bits de uno de los campos de la pseudo-instrucci&oacute;n.
	      </p>
	      <p>
	         
	      </p>

      </div>


      <div id="help_assembly_format">
      <h1>Ensamblador en WepSIM</h1>

	      <p>
	      </p>
	      <p>
	        El c&oacute;digo en ensamblador se describe en un fichero de texto con una primera secci&oacute;n de datos (.data) y una segunda secci&oacute;n para el c&oacute;digo (.text)<br />
	        <br />
	        En la secci&oacute;n de datos es posible definir las variables y constantes que se alojar&aacute;n en el segmento de datos de la memoria principal. Dicha secci&oacute;n comienza con la directiva <i>.data</i>. Las
	        directivas que permiten especificar los distintos tipos de datos que pueden definirse son:
	      </p>
	      <p>
	        &middot;       <b>.ascii:</b> va seguida de la cadena de caracteres, instruyendo al ensamblador para crear una zona de memoria con datos, y almacenar en ella la cadena que se indique.
	      </p>
	      <p>
	        &middot;       <b>.asciiz:</b> va seguida de la cadena de caracteres, instruyendo al ensamblador para crear una zona de memoria con datos, y almacenar en ella la cadena que se muestra terminado por
	        un byte con valor cero.
	      </p>
	      <p>
	        &middot;       <b>.byte:</b> va seguida de uno o m&aacute;s valores que formar&aacute;n parte del valor de la variable. En caso de varios valores, dichos valores se separar&aacute;n por coma. Para los valores se puede
	        usar: <b>car&aacute;cter, octal, hexadecimal y decimal</b>.
	      </p>
	      <p>
	        &middot;       <b>.half:</b> va seguida de uno o m&aacute;s valores que formar&aacute;n parte del valor de la variable. En caso de varios valores, dichos valores se separar&aacute;n por coma.<br />
	        Para los valores se puede usar: <b>octal, hexadecimal y decimal.</b>
	      </p>
	      <p>
	        &middot;       <b>.word:</b> va seguida de uno o m&aacute;s valores que formar&aacute;n parte del valor de la variable. En caso de varios valores, dichos valores se separar&aacute;n por coma.<br />
	        Para los valores se puede usar: <b>octal, hexadecimal y decimal.</b>
	      </p>
	      <p>
	        &middot;       <b>.space:</b> va seguida del n&uacute;mero de bytes, en formato decimal, que el usuario desea reservar en memoria.
	      </p>
	      <p>
	        El formato de un valor de los tipos de datos comentados es:
	      </p>
	      <p>
	        &middot;       <b>Cadena de caracteres:</b> secuencia de caracteres entre comillas dobles.<br />
	        Por ejemplo: "hola 123\n"
	      </p>
	      <p>
	        &middot;       <b>Car&aacute;cter:</b> car&aacute;cter entre comillas simples.<br />
	        Por ejemplo: &apos;c&apos;.
	      </p>
	      <p>
	        &middot;       <b>Octal:</b> un n&uacute;mero que comienza por cero y sus d&iacute;gitos son menores que ocho. Por ejemplo: 012.
	      </p>
	      <p>
	        &middot;       <b>Hexadecimal:</b> un n&uacute;mero que comienza por el prefijo 0x y sus d&iacute;gitos son del cero al nueve y las letras a, b, c, d, e y f.<br />
	        Por ejemplo: 0x12.
	      </p>
	      <p>
	        &middot;       <b>Decimal:</b> un n&uacute;mero que no est&aacute; en formato octal o hexadecimal con d&iacute;gitos comprendidos entre el cero y el nueve (ambos incluidos).<br />
	        Por ejemplo: 12.
	      </p>
	      <p>
	        En la secci&oacute;n de c&oacute;digo es posible definir las subrutinas que se alojar&aacute;n en el segmento de c&oacute;digo de la memoria principal. Dicha secci&oacute;n comienza con la directiva <i>.text</i>.
	      </p>
	      <p>
	         
	      </p>
	      <p>
	        Es posible usar comentarios de l&iacute;nea usando el car&aacute;cter #<br />
	        Todo lo que hay a continuaci&oacute;n de este car&aacute;cter hasta el final de l&iacute;nea ser&aacute; ignorado por el ensamblador.
	      </p>
	      <p>
	        Un ejemplo programa ser&iacute;a:
	      </p>
	      <ul>
	      <p>
	        .data
	      </p>
	      <p>
	                  age1:    .word   0x12345678, 20     
	      </p>
	      <p>
	                  age2:    .word   20 , 10
	      </p>
	      <p>
	                  resultado: .word 0
	      </p>
	      <p>
	                  # 32-bit word initialized with decimal
	      </p>
	      <p>
	                  texto: .ascii "Hola\t"
	      </p>
	      <p>
	                  texto2: .asciiz "Hola\t"
	      </p>
	      <p>
	                  hueco: .space 16
	      </p>
	      <p>
	        .text
	      </p>
	      <p>
	        .globl main
	      </p>
	      <p>
	        main:  li $3 2
	      </p>
	      <p>
	                   li $4 1
	      </p>
	      <p>
	                   li $5 0<br />
	        <br />
	      </p>
	      </ul>
	      <p class="cleanuphtml-2">
	        <a class="cleanuphtml-1" name="_Toc438322908">Figura</a> <b>19</b> <b>Ejemplo de secciones de dato y c&oacute;digo en ensamblador para probar microc&oacute;digos</b><b><br />
	        <br /></b>
	      </p>

      </div>


      <div id="help_simulator_arch">
      <h1>La arquitectura de WepSIM</h1>

	      <p> </p>
	      <p>
	        El sistema completo simulado (v&eacute;ase la <b class="cleanuphtml-1">Figura 1</b>) incluye adem&aacute;s del procesador, una memoria de 1 MB (direccionada por bytes), un teclado, una pantalla y un
	        dispositivo de entrada y salida capaz de generar interrupciones.
	      </p>
	      <p>
	      </p>
	      <p>
	        <img max-width="90%" width="90%" id="Imagen 2" src="help/simulator/simulator001.jpg" alt="" name="Imagen 2" />
	      </p>
	      <p class="cleanuphtml-3">
	        <a name="_Toc438322890"></a><a class="cleanuphtml-2" name="_Ref434141389">Figura</a> <b>1</b> <b>Sistema Completo</b>
	      </p>
	      <p>
	      </p>
	      <p>
	        El procesador (v&eacute;ase la <b class="cleanuphtml-1">Figura 2</b>) es de 32 bits, trabaja con hasta 64 instrucciones definibles por el usuario (estilo MIPS, ARM, etc.), dispone de un banco de
	        registros de 32 registros y usa un mapa de E/S separado.
	      </p>
	      <p>
	      </p>
	      <p class="cleanuphtml-3">
	        <img max-width="90%" width="50%" id="Imagen 9" src="help/simulator/simulator002.jpg" alt="" name="Imagen 9" />
	      </p>
	      <p class="cleanuphtml-3">
	        <a name="_Toc438322891"></a><a class="cleanuphtml-2" name="_Ref434142801">Figura</a> <b>2</b> <b>Procesador  WepSIM</b>
	      </p>
	      <p>
	      </p>
	      <p>
	        El procesador utiliza direcciones de  32 bits, usando el bus de direcciones (<i>Address Bus</i>) para direcciones y el bus de datos (<i>Data Bus</i>) para enviar/recibir los datos a/desde
	        memoria.
	      </p>
	      <p>
	         
	      </p>
	      <p>
	        El procesador espera un ciclo para que la memoria realice la operaci&oacute;n de lectura (activada con la se&ntilde;al R) o bien la operaci&oacute;n de escritura (activada con la se&ntilde;al W).
	      </p>
	      <p>
	         
	      </p>
	      <p>
	        La memoria usa una configuraci&oacute;n <i>Little-Endian</i> tal y como se muestra en <b class="cleanuphtml-1">Figura 3</b>.
	      </p>
	      <p>
	         
	      </p>
	      <p class="cleanuphtml-3">
	        <img max-width="90%" width="60%" id="Imagen 22" src="help/simulator/simulator003.jpg" alt="" name="Imagen 22" />
	      </p>
	      <p class="cleanuphtml-3">
	         
	      </p>
	      <p class="cleanuphtml-3">
	        <a name="_Toc438322892"></a><a class="cleanuphtml-2" name="_Ref434149687">Figura</a> <b>3</b> <b>Ordenaci&oacute;n de bytes en memoria</b>
	      </p>
	      <p>
	         
	      </p>
	      <p>
	        Por tanto el byte menos significativo est&aacute; en la direcci&oacute;n m&aacute;s baja de memoria.
	      </p>
	      <p>
	         
	      </p>
	      <p>
	        El acceso a la memoria se realiza a nivel de byte.
	      </p>
	      <p>
	        Para la selecci&oacute;n del byte se precisa indicar por un lado la direcci&oacute;n de la palabra donde se encuentra (A<sub>31</sub>...A<sub>2</sub>00), y por otro lado el byte dentro de esa palabra al que se desea acceder (BE<sub>3</sub>...BE<sub>0</sub>).
	      </p>
	      <p>
	         
	      </p>
	      <p class="cleanuphtml-3">
	        <img max-width="90%" width="50%" id="Imagen 24" src="help/simulator/simulator004.jpg" alt="" name="Imagen 24" />
	      </p>
	      <p class="cleanuphtml-3">
	        <a name="_Toc438322893"></a><a class="cleanuphtml-2" name="_Ref434150369">Figura</a> <b>4</b> <b>M&oacute;dulo de memoria</b>
	      </p>
	      <p>
	         
	      </p>
	      <p>
	        La <b class="cleanuphtml-1">Figura 4</b> muestra estas entradas/salidas comentadas, a las que hay que unir las se&ntilde;ales R y W para la petici&oacute;n de lectura y escritura respectivamente.
	      </p><br clear="all" />
	      <p>
	         
	      </p>
	      <h2>
	        <a name="_Toc438325788">Organizaci&oacute;n interna: se&ntilde;ales de control</a>
	      </h2>
	      <p>
	         
	      </p>
	      <p>
	        La unidad de control en WepSIM es microprogramable. Su memoria de control consta de 4096 micropalabras de 76 bits cada una (v&eacute;ase <b class="cleanuphtml-1">Figura 5</b>).
	      </p>
	      <p class="cleanuphtml-3">
	        <img max-width="90%" width="80%" id="Imagen 12" src="help/simulator/simulator005.jpg" alt="" name="Imagen 12" />
	      </p>
	    <br clear="all" />
	    <div class="WordSection2"></div>
	    <br clear="all" />
	    <div class="WordSection3">
	      <p class="cleanuphtml-3">
	        <a name="_Toc438322894"></a><a class="cleanuphtml-2" name="_Ref434141431">Figura</a> <b>5</b> <b>Formato de microinstrucci&oacute;n</b>
	      </p>
	      <p>
	        La nomenclatura general usada para el nombre las se&ntilde;ales de control es la siguiente:
	      </p>
	      <p>
	        ·       Cx: se&ntilde;al de carga de registro x
	      </p>
	      <p>
	        ·       Tx: se&ntilde;al de activaci&oacute;n triestado x
	      </p>
	      <p>
	        ·       Ry: identificador de registro para el punto de salida de valor y
	      </p>
	      <p>
	        ·       Mx: selecci&oacute;n en multiplexor x
	      </p>
	      <p>
	        Adicionalmente la se&ntilde;al LC indica la escritura en el banco de registros, Cop indica la operaci&oacute;n a realizar en la ALU, SelP selecciona qu&eacute; bits actualizar en el registro de estado (SR), A1A0
	        son los dos bits menos significativos de una direcci&oacute;n de memoria y BW permite especificar el tama&ntilde;o del dato al que se accede en memoria: una palabra completa, media palabra o un byte.
	      </p>
	      <p>
	         
	      </p>
	      <p>
	        El procesador (v&eacute;ase la figura <b class="cleanuphtml-1">Figura 6</b>) puede considerarse dividido en 7 partes: acceso a memoria (MAR, MBR, etc.), gesti&oacute;n del registro contador de programa
	        (PC, etc.), gesti&oacute;n del registro de instrucci&oacute;n (IR, etc.), unidad de control (<i>Control Unit</i>), banco de registros (<i>Register File</i>), ALU y gesti&oacute;n del registro de estado (SR,
	        etc.).
	      </p>
	      <p>
	        <img max-width="90%" width="90%" id="Imagen 5" src="help/simulator/simulator006.jpg" alt="" name="Imagen 5" />
	      </p>
	      <p class="cleanuphtml-3">
	        <a name="_Toc438322895"></a><a class="cleanuphtml-2" name="_Ref434141629">Figura</a> <b>6</b> <b>Detalle del procesador</b>
	      </p>
	      <p>
	        <br />
	        La unidad de control (v&eacute;ase la figura <b class="cleanuphtml-1">Figura 7</b>) a su vez est&aacute; dividida en 5 partes: el control de la siguiente microdirecci&oacute;n (MUX A, etc.), la transformaci&oacute;n del
	        c&oacute;digo de operaci&oacute;n a la microdirecci&oacute;n correspondiente (co2uAddr), el control de la condici&oacute;n de selecci&oacute;n de microdirecci&oacute;n (MUX B, MUX C, etc.), la memoria de control junto con el registro
	        de microinstrucci&oacute;n y por &uacute;ltimo los selectores de RA, RB, RC y Cop.
	      </p>
	      <p>
	        <img max-width="90%" width="90%" id="Imagen 7" src="help/simulator/simulator007.jpg" alt="" name="Imagen 7" />
	      </p>
	      <p class="cleanuphtml-3">
	        <a name="_Toc438322896"></a><a class="cleanuphtml-2" name="_Ref434141950">Figura</a> <b>7</b> <b>Detalle de la unidad de control</b>
	      </p>
	      <p>
	        Para direccionar la memoria de control se precisa direcciones de 12 bits us&aacute;ndose secuenciamiento impl&iacute;cito. Es posible indicar como microdirecci&oacute;n de memoria de control (v&eacute;ase <b class=
	        "cleanuphtml-1">Figura 8</b>) la siguiente posici&oacute;n, usar parte de la microinstrucci&oacute;n, usar la salida de una ROM con la microdirecci&oacute;n de comienzo asociada a un c&oacute;digo de operaci&oacute;n o bien la
	        microdirecci&oacute;n cero (0) a partir de la cual comienza el <i>fetch</i>.
	      </p>
	      <p class="cleanuphtml-3">
	        <img max-width="90%" width="90%" id="Imagen 11" src="help/simulator/simulator008.jpg" alt="" name="Imagen 11" />
	      </p>
	      <p class="cleanuphtml-3">
	        <a name="_Toc438322897"></a><a class="cleanuphtml-2" name="_Ref434143860">Figura</a> <b>8</b> <b>Opciones para el MUX A</b>
	      </p>
	      <p class="cleanuphtml-4"></p>
	      <p class="cleanuphtml-4"></p>
	    </div>

      </div>


      <div id="help_simulator_screens">
      <h1>Ejecuci&oacute;n en WepSIM</h1>

	      <p>
	      </p>
	      <p>
	        El ciclo de trabajo supone (normalmente) los siguientes pasos:
		<ul>
                <li>Cargar un firmware de trabajo (ver Gesti&oacute;n de microc&oacute;digo).</li>
                <li>Cargar un programa en ensamblador que use el firmware de trabajo (ver Gesti&oacute;n del ensamblador).</li>
		<li>Ir a la pantalla principal (simulador) para ejecutar el programa en ensamblador que use el firmware de trabajo (ver Simulaci&oacute;n en WepSIM).</li>
		</ul>
	      </p>
	      <p>
	      </p>


	      <a name="firmware_screens"></a>
              <h2>Gesti&oacute;n de microc&oacute;digo en WepSIM</h2>

	      <p>
	        Un fichero de texto con las tres secciones antes comentadas
                (microc&oacute;digo, nombrado de registro y definici&oacute;n de pseudo-instrucciones) se carga en la pantalla de Firmware. Para acceder a dicha
	        pantalla se ha de ir al men&uacute; (parte superior derecha) e indicar la opci&oacute;n <i>Firmware</i> (v&eacute;ase la <b class="cleanuphtml-4">Figura 16</b>)
	      </p>
	      <p>
	         
	      </p>
	      <p>
	        <img max-width="90%" width="90%" id="Imagen 1" src="help/simulator/firmware001.jpg" alt="" name="Imagen 1" />
	      </p>
	      <p class="cleanuphtml-2">
	        <a name="_Ref434190846"></a><a name="_Toc438322905"></a><a class="cleanuphtml-1" name="_Ref434190877">Figura</a> <b>16</b> <b>Pantalla principal: opci&oacute;n de carga de firmware</b>
	      </p>
	      <p>
	        <br />
	        A continuaci&oacute;n aparecer&aacute; una pantalla con un cuadro de texto que permite indicar el <i>firmware</i> (las tres secciones antes comentadas). Es posible cargar un <i>firmware</i> existente
	        usando el bot&oacute;n "Load" de la barra inferior, modificar un <i>firmware</i> anteriormente cargado o salvar el firmware en curso con el bot&oacute;n "Save" de la barra inferior. Una vez se indique el
	        firmware es preciso hacer clic en el bot&oacute;n "&#181;compile" para pasar a binario y cargar en la memoria de control dicho firmware, como se muestra en la <b class="cleanuphtml-4">Figura 17</b>.
	      </p>
	      <p>
	        <img max-width="90%" width="90%" id="Imagen 2" src="help/simulator/firmware002.jpg" alt="" name="Imagen 2" />
	      </p>
	      <p class="MsoNormal cleanuphtml-5"></p>
	      <table cellpadding="0" cellspacing="0" align="left">
	      </table> <br clear="all" />
	      <p class="cleanuphtml-2">
	        <a name="_Toc438322906"></a><a class="cleanuphtml-1" name="_Ref434191423">Figura</a> <b>17</b> <b>Pantalla firmware: cuadro de texto con firmware a cargar</b>
	      </p>
	      <p>
	        <br />
	        Una vez cargado el nuevo <i>firmware</i> correctamente aparecer&aacute; la pantalla mostrada en la <b class="cleanuphtml-4">Figura 18</b> en la que se muestra la memoria de control con los valores
	        que almacena.
	      </p>
	      <p>
	        <img max-width="90%" width="90%" id="Imagen 3" src="help/simulator/firmware004.jpg" alt="" name="Imagen 3" />
	      </p>
	      <p class="cleanuphtml-2">
	        <a name="_Toc438322907"></a><a class="cleanuphtml-1" name="_Ref434191551">Figura</a> <b>18</b> <b>Pantalla firmware: firmware finalmente compilado</b>
	      </p>
	      <p>
	        <br />
	        El siguiente paso es la carga del programa ensamblador que permita probar este <i>firmware</i>, para ello podemos pulsar el bot&oacute;n "<i>Assembly</i>" de la barra inferior.
	      </p>
	      <p>
	         
	      </p>


	      <a name="assembly_screens"></a>
              <h2>Gesti&oacute;n del ensamblador en WepSIM</h2>

	      <p>
	        Un fichero de texto con las dos secciones antes comentadas
                (datos y c&oacute;digo) se carga en la pantalla de Ensamblador. Para acceder a dicha pantalla se ha de ir al men&uacute; (parte superior derecha)
	        e indicar la opci&oacute;n Assembly (v&eacute;ase la <b class="cleanuphtml-3">Figura 16</b>)<br />
	        <br />
	      </p>
	      <p>
	        <img max-width="90%" width="90%" id="Imagen 3" src="help/simulator/assembly002.jpg" alt="" name="Imagen 3" />
	      </p>
	      <p class="cleanuphtml-2">
	        <a name="_Toc438322909"></a><a class="cleanuphtml-1" name="_Toc434155501">Figura</a> <b>20</b> <b>Pantalla principal: opci&oacute;n de carga de c&oacute;digo ensamblador</b>
	      </p>
	      <p>
	        A continuaci&oacute;n aparecer&aacute; una pantalla con un cuadro de texto que permite indicar el c&oacute;digo en ensamblador. Es posible cargar un c&oacute;digo existente usando el bot&oacute;n "Load" de la barra superior,
	        modificar un c&oacute;digo anteriormente cargado o salvar el c&oacute;digo actualmente en cargado con el bot&oacute;n "Save" de la barra inferior.
	      </p>
	      <p>
	        Una vez se indique el c&oacute;digo es preciso hacer clic en el bot&oacute;n "Compile" para pasar a binario y cargar en la memoria de principal el binario resultante, 
		tal y como se muestra en la <b class="cleanuphtml-3">Figura 21</b>. 
	      </p>
	      <p>
	         
	      </p>
	      <p>
	        <img max-width="90%" width="90%" id="Imagen 28" src="help/simulator/assembly003.jpg" alt="" name="Imagen 28" />
	      </p>
	      <p class="cleanuphtml-2">
	        <a name="_Toc438322910"></a><a class="cleanuphtml-1" name="_Ref434192102">Figura</a> <b>21</b> <b>Pantalla ensamblador: cuadro de texto con ensamblador a cargar</b><b><br />
	        <br /></b>
	      </p>
	      <p>
	        Una vez compilado, se pasar&aacute; a la pantalla indicada en la <b class="cleanuphtml-3">Figura 23</b>, donde se mostrar&aacute; el contenido de la memoria principal en binario.
	      </p>
	      <p>
	         
	      </p>
	      <p>
	        <img max-width="90%" width="90%" id="Imagen 30" src="help/simulator/assembly005.jpg" alt="" name="Imagen 30" />
	      </p>
	      <p class="cleanuphtml-2">
	        <a name="_Toc438322912"></a><a class="cleanuphtml-1" name="_Ref434192450">Figura</a> <b>23</b> <b>Pantalla ensamblador: c&oacute;digo finalmente compilado</b>
	      </p>
	      <p>
	        <br />
	        El siguiente paso es ir a la pantalla principal para ejecutar la combinaci&oacute;n de <i>firmware</i> y ensamblador cargado, para lo que ha de pulsar el bot&oacute;n "Simulador" de la barra inferior.
	      </p>
	      <p>
	      </p>


	      <a name="simulator_screens"></a>
              <h2>Simulaci&oacute;n en WepSIM</h2>

	      <p>
	        Estando en la pantalla principal es posible visualizar:
	      </p>
	      <ul>
	      <li>
	        El contenido de la memoria de control (v&eacute;ase la <b>Figura 24</b>), con las se&ntilde;ales que est&aacute;n asociadas a cada ciclo. Para ello ha de pulsar el bot&oacute;n "<i>Control Memory</i>" en
	        la barra de botones situada en la parte superior derecha de la pantalla principal.<br />
	        Se destaca las se&ntilde;ales que en el presente ciclo de reloj est&aacute;n activadas en azul con letra algo m&aacute;s grande.<br />
	        Se dispone de una barra de desplazamiento para poder inspeccionar todo el contenido de la memoria de control.
	      </li>
	      <li>
	        El contenido de la memoria principal (v&eacute;ase la <b class="cleanuphtml-1">Figura 25</b>), con las instrucciones en ensamblador a ejecutar. Para estas, es posible establecer un punto de
	        ruptura haciendo clic en la columna <i>breakpoints</i>. Al establecer un punto de ruptura aparecer&aacute; un icono en dicha columna.
	      </li>
	      </ul>
	      <p>
	        <img max-width="90%" width="90%" id="Imagen 1" src="help/simulator/simulator009.jpg" alt="" name="Imagen 1" />
	      </p>
	      <p class="cleanuphtml-3">
	        <a name="_Toc438322913"></a><a class="cleanuphtml-2" name="_Ref434192973">Figura</a> <b>24</b> <b>Pantalla principal: visualizaci&oacute;n de la memoria de control</b>
	      </p>
	      <p>
	      </p>
	      <p>
	        <img max-width="90%" width="90%" id="Imagen 3" src="help/simulator/simulator010.jpg" alt="" name="Imagen 3" />
	      </p>
	      <p class="cleanuphtml-3">
	        <a name="_Toc438322914"></a><a class="cleanuphtml-2" name="_Ref434193222">Figura</a> <b>25</b> <b>Pantalla principal: visualizaci&oacute;n del c&oacute;digo en la memoria principal</b>
	      </p>
	      <p>
	      </p>
	      <p>
	        Estando en la pantalla principal es posible ejecutar:
	      </p>
	      <p>
	        ·       Microinstrucci&oacute;n a microinstrucci&oacute;n pulsando el bot&oacute;n "µInstrucci&oacute;n" (v&eacute;ase la <b class="cleanuphtml-1">Figura 26</b>), de forma que se pasar&aacute; al siguiente ciclo de reloj y se
	        generar&aacute;n las se&ntilde;ales de control asociadas.
	      </p>
	      <p>
	        ·       Instrucci&oacute;n a instrucci&oacute;n pulsando el bot&oacute;n "Instrucci&oacute;n" (v&eacute;ase la <b class="cleanuphtml-1">Figura 26</b>) de forma que se generar&aacute;n todos los ciclos de reloj asociados al
	        microprograma de la instrucci&oacute;n, parando al principio del <i>fetch</i>.
	      </p>
	      <p>
	      </p>
	      <p>
	        <img max-width="90%" width="90%" id="Imagen 4" src="help/simulator/simulator011.jpg" alt="" name="Imagen 4" />
	      </p>
	      <p class="cleanuphtml-3">
	        <a name="_Toc438322915"></a><a class="cleanuphtml-2" name="_Ref434193775">Figura</a> <b>26</b> <b>Pantalla principal: opciones para la ejecuci&oacute;n</b>
	      </p>
	      <p>
	        <br />
	        Dando al bot&oacute;n "<i>Registers</i>" en la barra de botones situada en la parte superior derecha de la pantalla principal (v&eacute;ase la <b class="cleanuphtml-1">Figura 26</b>) es posible ver c&oacute;mo
	        los valores de los registros son modificados durante la ejecuci&oacute;n.
	      </p>
	      <p>
	        Es posible visualizar tambi&eacute;n la unidad de control como se muestra en la <b class="cleanuphtml-1">Figura 27</b>.
	      </p>
	      <p>
	      </p>
	      <p>
	        <img max-width="90%" width="90%" id="Imagen 8" src="help/simulator/simulator012.jpg" alt="" name="Imagen 8" />
	      </p>
	      <p class="cleanuphtml-3">
	        <a name="_Toc438322916"></a><a class="cleanuphtml-2" name="_Ref434194139">Figura</a> <b>27</b> <b>Pantalla principal: visualizaci&oacute;n de la unidad de control</b>
	      </p>
	      <p>
	        As&iacute; como tambi&eacute;n es posible reiniciar la ejecuci&oacute;n haciendo clic al bot&oacute;n "Reset" situado en la barra de botones que aparece en la parte superior de la pantalla.
	      </p>
	      <p>
	      </p>
	      <p>
	      </p>

      </div>


      <div id="help_checker">

              Es posible comprobar que el estado actual cumple los requisitos deseados:
	      <p>
	      <ul>
	        <li>Para comprobar el estado actual, por favor introduzca los requisitos y presione "check".</li>
	        <c>
	        Por ejemplo:<br>
	        <textarea aria-label="checks to perform" rows="2">
register 5 >= 8 ; memory 1 = 0x10; screen 0 == first_line
	        </textarea>
	        </c>
	        <li>Para limpiar los requisitos, presione "clean".</li>
	      </ul>
	      <p>
	      <b>NOTA: los puntos y coma son necesarios.</b>
	      <br>
	      Cuando no se indican requisitos, se toma el estado inicial como base de comparación.

      </div>


      <div id="help_dumper">

              Es posible conocer los requisitos del estado en el instante actual.<br>
	      Puede ser usado para comprobar las diferencias entre dos instantes distintos.<br>
	      <br>
	      <ul>
	        Por ejemplo:<br>
	        <textarea aria-label="checks to perform" rows="2">
register 5 >= 8 ; memory 1 = 0x10; screen 0 == first_line
	        </textarea>
	      </ul>
	      <p>
	      <b>NOTA: los puntos y coma son necesarios.</b>

      </div>

  </body>
</html>
