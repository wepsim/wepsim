<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <title></title>
	<meta charset="UTF-8">
	<meta http-equiv="Content-type" content="text/html; charset=UTF-8">
    <style type="text/css">
/*<![CDATA[*/
    :link { color: #0563C1 }
    :visited { color: #954F72 }
    p.cleanuphtml-5 {margin-bottom:8.0pt;line-height:80%}
    b.cleanuphtml-4 {font-style: italic}
    p.cleanuphtml-3 {font-weight: bold}
    p.cleanuphtml-2 {text-align: center}
    a.cleanuphtml-1 {font-weight: bold}
    /*]]>*/
    </style>

  <!-- Clean HTML generated by http://www.cleanuphtml.com/ -->
	<meta name="Generator" content="Cleanup HTML"></head>
  <body>

      <div id="help_simulator_arch">
      <h1>La arquitectura de WepSIM</h1>

	      <p> </p>
	      <p>
	        El sistema completo simulado (v&eacute;ase la <b class="cleanuphtml-1">Figura 1</b>) incluye adem&aacute;s del procesador, una memoria de 1 MB (direccionada por bytes), un teclado, una pantalla y un
	        dispositivo de entrada y salida capaz de generar interrupciones.
	      </p>
	      <p>
	      </p>
	      <p>
	      </p>
	      <p class="cleanuphtml-3">
	        <a name="_Toc438322890"></a><a class="cleanuphtml-2" name="_Ref434141389">Figura</a> <b>1</b> <b>Sistema Completo</b>
	      </p>
	      <p>
	      </p>
	      <p>
	        El procesador (v&eacute;ase la <b class="cleanuphtml-1">Figura 2</b>) es de 32 bits, trabaja con hasta 64 instrucciones definibles por el usuario (estilo MIPS, ARM, etc.), dispone de un banco de
	        registros de 32 registros y usa un mapa de E/S separado.
	      </p>
	      <p>
	      </p>
	      <p class="cleanuphtml-3">
	      </p>
	      <p class="cleanuphtml-3">
	        <a name="_Toc438322891"></a><a class="cleanuphtml-2" name="_Ref434142801">Figura</a> <b>2</b> <b>Procesador  WepSIM</b>
	      </p>
	      <p>
	      </p>
	      <p>
	        El procesador utiliza direcciones de  32 bits, usando el bus de direcciones (<i>Address Bus</i>) para direcciones y el bus de datos (<i>Data Bus</i>) para enviar/recibir los datos a/desde
	        memoria.
	      </p>
	      <p>
	         
	      </p>
	      <p>
	        El procesador espera un ciclo para que la memoria realice la operaci&oacute;n de lectura (activada con la se&ntilde;al R) o bien la operaci&oacute;n de escritura (activada con la se&ntilde;al W).
	      </p>
	      <p>
	         
	      </p>
	      <p>
	        La memoria usa una configuraci&oacute;n <i>Little-Endian</i> tal y como se muestra en <b class="cleanuphtml-1">Figura 3</b>.
	      </p>
	      <p>
	         
	      </p>
	      <p class="cleanuphtml-3">
	      </p>
	      <p class="cleanuphtml-3">
	         
	      </p>
	      <p class="cleanuphtml-3">
	        <a name="_Toc438322892"></a><a class="cleanuphtml-2" name="_Ref434149687">Figura</a> <b>3</b> <b>Ordenaci&oacute;n de bytes en memoria</b>
	      </p>
	      <p>
	         
	      </p>
	      <p>
	        Por tanto el byte menos significativo est&aacute; en la direcci&oacute;n m&aacute;s baja de memoria.
	      </p>
	      <p>
	         
	      </p>
	      <p>
	        El acceso a la memoria se realiza a nivel de byte.
	      </p>
	      <p>
	        Para la selecci&oacute;n del byte se precisa indicar por un lado la direcci&oacute;n de la palabra donde se encuentra (A<sub>31</sub>...A<sub>2</sub>00), y por otro lado el byte dentro de esa palabra al que se desea acceder (BE<sub>3</sub>...BE<sub>0</sub>).
	      </p>
	      <p>
	         
	      </p>
	      <p class="cleanuphtml-3">
	      </p>
	      <p class="cleanuphtml-3">
	        <a name="_Toc438322893"></a><a class="cleanuphtml-2" name="_Ref434150369">Figura</a> <b>4</b> <b>M&oacute;dulo de memoria</b>
	      </p>
	      <p>
	         
	      </p>
	      <p>
	        La <b class="cleanuphtml-1">Figura 4</b> muestra estas entradas/salidas comentadas, a las que hay que unir las se&ntilde;ales R y W para la petici&oacute;n de lectura y escritura respectivamente.
	      </p>

	      <p>
	      El hardware simulado puede configurarse:<br>
	      <ul>
	         <li>
                 <b>Memoria</b>: n&uacute;mero de ciclos que la memoria precisa para buscar un dato.<br>
                 El valor por defecto es cero, lo que significa que el dato est&aacute; disponible
                 en el siguiente ciclo de reloj despu&eacute;s de la petici&oacute;n.
                 </li>
	         <li>
                 <b>I/O</b>: n&uacute;mero de ciclos hasta lanzar una interrupci&oacute;n.<br>
                 El valor por defecto es cero y esto significa que no se generar&aacute; 
                 interrupciones por parte del dispositivo.
                 Si el 'CLK period' es, por ejemplo, 100 y el valor de 'Probability' es 1 entonces
                 cada 100 ciclos de reloj se generar&aacute; la interrupci&oacute;n asociada.
                 Si la probabilidad es 0.5 entonces la interrupci&oacute;n asociada 
                 se generar&aacute; con una probabilidad del 50%.
                 </li>
	      </ul>
	      </p>

	      <h2>
	        <a name="_Toc438325788">Organizaci&oacute;n interna: se&ntilde;ales de control</a>
	      </h2>
	      <p>
	         
	      </p>
	      <p>
	        La unidad de control en WepSIM es microprogramable. Su memoria de control consta de 4096 micropalabras de 76 bits cada una (v&eacute;ase <b class="cleanuphtml-1">Figura 5</b>).
	      </p>
	      <p class="cleanuphtml-3">
	      </p>
	    <br clear="all" />
	    <div class="WordSection2"></div>
	    <br clear="all" />
	    <div class="WordSection3">
	      <p class="cleanuphtml-3">
	        <a name="_Toc438322894"></a><a class="cleanuphtml-2" name="_Ref434141431">Figura</a> <b>5</b> <b>Formato de microinstrucci&oacute;n</b>
	      </p>
	      <p>
	        La nomenclatura general usada para el nombre las se&ntilde;ales de control es la siguiente:
	      </p>
	      <p>
	        路       Cx: se&ntilde;al de carga de registro x
	      </p>
	      <p>
	        路       Tx: se&ntilde;al de activaci&oacute;n triestado x
	      </p>
	      <p>
	        路       Ry: identificador de registro para el punto de salida de valor y
	      </p>
	      <p>
	        路       Mx: selecci&oacute;n en multiplexor x
	      </p>
	      <p>
	        Adicionalmente la se&ntilde;al LC indica la escritura en el banco de registros, Cop indica la operaci&oacute;n a realizar en la ALU, SelP selecciona qu&eacute; bits actualizar en el registro de estado (SR), A1A0
	        son los dos bits menos significativos de una direcci&oacute;n de memoria y BW permite especificar el tama&ntilde;o del dato al que se accede en memoria: una palabra completa, media palabra o un byte.
	      </p>
	      <p>
	         
	      </p>
	      <p>
	        El procesador (v&eacute;ase la figura <b class="cleanuphtml-1">Figura 6</b>) puede considerarse dividido en 7 partes: acceso a memoria (MAR, MBR, etc.), gesti&oacute;n del registro contador de programa
	        (PC, etc.), gesti&oacute;n del registro de instrucci&oacute;n (IR, etc.), unidad de control (<i>Control Unit</i>), banco de registros (<i>Register File</i>), ALU y gesti&oacute;n del registro de estado (SR,
	        etc.).
	      </p>
	      <p>
	      </p>
	      <p class="cleanuphtml-3">
	        <a name="_Toc438322895"></a><a class="cleanuphtml-2" name="_Ref434141629">Figura</a> <b>6</b> <b>Detalle del procesador</b>
	      </p>
	      <p>
	        <br />
	        La unidad de control (v&eacute;ase la figura <b class="cleanuphtml-1">Figura 7</b>) a su vez est&aacute; dividida en 5 partes: el control de la siguiente microdirecci&oacute;n (MUX A, etc.), la transformaci&oacute;n del
	        c&oacute;digo de operaci&oacute;n a la microdirecci&oacute;n correspondiente (co2uAddr), el control de la condici&oacute;n de selecci&oacute;n de microdirecci&oacute;n (MUX B, MUX C, etc.), la memoria de control junto con el registro
	        de microinstrucci&oacute;n y por &uacute;ltimo los selectores de RA, RB, RC y Cop.
	      </p>
	      <p>
	      </p>
	      <p class="cleanuphtml-3">
	        <a name="_Toc438322896"></a><a class="cleanuphtml-2" name="_Ref434141950">Figura</a> <b>7</b> <b>Detalle de la unidad de control</b>
	      </p>
	      <p>
	        Para direccionar la memoria de control se precisa direcciones de 12 bits us&aacute;ndose secuenciamiento impl&iacute;cito. Es posible indicar como microdirecci&oacute;n de memoria de control (v&eacute;ase <b class=
	        "cleanuphtml-1">Figura 8</b>) la siguiente posici&oacute;n, usar parte de la microinstrucci&oacute;n, usar la salida de una ROM con la microdirecci&oacute;n de comienzo asociada a un c&oacute;digo de operaci&oacute;n o bien la
	        microdirecci&oacute;n cero (0) a partir de la cual comienza el <i>fetch</i>.
	      </p>
	      <p class="cleanuphtml-3">
	      </p>
	      <p class="cleanuphtml-3">
	        <a name="_Toc438322897"></a><a class="cleanuphtml-2" name="_Ref434143860">Figura</a> <b>8</b> <b>Opciones para el MUX A</b>
	      </p>
	      <p class="cleanuphtml-4"></p>
	      <p class="cleanuphtml-4"></p>
	    </div>

      </div>

  </body>
</html>
